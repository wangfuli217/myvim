#!/bin/bash

[ -d /home/wangfuli/.nq ] || mkdir /home/wangfuli/.nq
export NQDIR=/home/wangfuli/.nq

declare preview='bat --color=always --style=header,numbers -H {2} {1}'

[ -n "$SSH_CLIENT" ] && {
    open=less
} || {
    open=xdg-open
}

if [ "$(uname -o)" = "Cygwin" ]; then
  open() {
    for f in $@; do
      cygstart "$(cygpath -w $f)"
    done
  }
fi

usage() {
  cat <<HEREDOC
   usage: frs -l -i -f filetype -s -S -w -L -v
   optional   arguments:
     -h       show this help message and exit
     -e       exact-match(fzf)       (default fuzzy match)
     -l       files-with-matches(rg) (output format)
     -L       follow symbolic links(rg)
     -i       ignore-case(rg)
     -s       case-sensitive(rg)     (default)
     -S       smart-case(rg)
     -w       word-regexp(rg)
     -F       fixed-strings(rg)
     -f <opt> filetype: rg --type-list
     -d <opt> maxdepth
     -v       verbose RG_PREFIX
  inst: frs -l fzf # output filename only
  inst: frs -L fzf # search symbolic links dirctory
  inst: frs -w fzf # search word match only
  inst: frs -s fzf # default search match mode: -i/-s/-S/-w
  inst: frs -v fzf # output RG_PREFIX config
HEREDOC
}

while getopts ':hlLifd:FsSwv' x; do
  case "$x" in
    h)
      usage
      exit 0
      ;;
    e) exactmatch=1 ;;
    l)
      list_files=1
      preview='bat --color=always --style=header,numbers {1}'
      ;;
    L) follow="1";;
    i) ignorecase="1" ;;
    f) filetype=${OPTARG} ;;
    d) maxdepth=${OPTARG} ;;
    F) fixedstrings="1" ;;
    s) casesensitive="1" ;;
    S) smartcase="1" ;;
    w) wordregexp="1" ;;
    v) verbose="1" ;;
  esac
done
shift $((OPTIND - 1))
unset x OPTARG OPTIND

# --preview 'bat --color=always {1} --highlight-line {2}' \
# Switch between Ripgrep launcher mode (CTRL-R) and fzf filtering mode (CTRL-F)
frsr_filename=$(mktemp -t frsr.XXXXXXXXXX)
frsf_filename=$(mktemp -t frsf.XXXXXXXXXX)
cleanup() {
  rm -f "$frsr_filename";
  rm -f "$frsf_filename";
}
trap cleanup EXIT


RG_PREFIX="rg --column --line-number --no-heading --crlf --color=always -d 1 -v '^#' | rg  ${list_files:+-l}"

[[ -n $filetype ]] && RG_PREFIX="$RG_PREFIX --type=$filetype "
[[ -n $maxdepth ]] && RG_PREFIX="$RG_PREFIX --max-depth=$maxdepth "
[[ -n $fixedstrings ]] && RG_PREFIX="$RG_PREFIX --fixed-strings "
[[ -n $ignorecase ]] && RG_PREFIX="$RG_PREFIX --ignore-case "
[[ -n $casesensitive ]] && RG_PREFIX="$RG_PREFIX --case-sensitive "
[[ -n $smartcase ]] && RG_PREFIX="$RG_PREFIX --smart-case "
[[ -n $wordregexp ]] && RG_PREFIX="$RG_PREFIX --word-regexp "
[[ -n $follow ]] && RG_PREFIX="$RG_PREFIX -L "
[[ -n $verbose ]] && { echo "RG_PREFIX=$RG_PREFIX"; exit; }

output=$(
INITIAL_QUERY="${*:-}"
: | fzf +m --ansi --disabled --query ${exactmatch:+-e} "$INITIAL_QUERY" \
  --bind "start:reload($RG_PREFIX {q})+unbind(ctrl-r)" \
  --bind "change:reload:sleep 0.1; $RG_PREFIX {q} || true" \
  --bind "ctrl-f:unbind(change,ctrl-f)+change-prompt(2. fzf> )+enable-search+rebind(ctrl-r)+transform-query(echo {q} > $frsr_filename; cat $frsf_filename)" \
  --bind "ctrl-r:unbind(ctrl-r)+change-prompt(1. ripgrep> )+disable-search+reload($RG_PREFIX {q} || true)+rebind(change,ctrl-f)+transform-query(echo {q} > $frsf_filename; cat $frsr_filename)" \
  --color "hl:-1:underline,hl+:-1:underline:reverse" \
  --prompt '1. ripgrep> ' \
  --delimiter : \
  --header '╱ CTRL-R (ripgrep mode) ╱ CTRL-F (fzf mode) ╱ ctrl-o:open ctrl-e:vim enter:less / -h rg|fzf arguments: [ -l;-L/-i/-d 1/-f c/-F/-s/-S/-w;-v ] /' \
  --preview='bat -n --color=always --style=numbers,changes,header --highlight-line {2} {1} 2>/dev/null || bat -n --color=always {1}' \
  --preview-window 'right,45%,+{2}+1/3,~1' \
  --bind 'ctrl-y:execute(put {1})' \
  --bind 'ctrl-p:execute(bat -p --highlight-line {2} --paging always {1})' \
  --bind 'ctrl-n:become(nq sh -c ./{1})' \
  --bind 'ctrl-o:execute($open {1})' \
  --bind 'ctrl-e:execute(vim {1} +{2})' \
  --bind 'ctrl-g:accept'
)

[ -z "$output" ] && exit

filename=$(echo $output | awk -F ':' '{print $1}')
startnum=$(echo $output | awk -F ':' '{print $2}')

sentencestart=0
detectstart=0
while read -r linedata; do
  [ -z "$linedata" ] && detectstart=$sentencestart
  sentencestart=$((sentencestart+1))
  if [ "$sentencestart" -eq "$startnum" ]; then
    break
  fi
done < $filename

[ "$detectstart" != "0" ] && startnum=$((detectstart+2)) || startnum=0

readnum=0
while read -r linedata; do
  readnum=$((readnum+1))
  if [ "$startnum" -gt "$readnum" ]; then
    continue
  fi
  [ -z "$linedata" ] && break
done < $filename

bat -p -r $startnum:$readnum $filename
