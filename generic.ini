#### without .git
# Macro             Detail                                                  Value
# $(VIM_FILEPATH)   File name of current buffer with full path              /home/wangfuli/json-c-test/json-c-array-add.c       $(VIM_FILEPATH)    # 当前 buffer 的文件名全路径
# $(VIM_FILENAME)   File name of current buffer without path                json-c-array-add.c                                  $(VIM_FILENAME)    # 当前 buffer 的文件名(没有前面的路径)
# $(VIM_FILEDIR)    Full path of current buffer without the file name       /home/wangfuli/json-c-test                          $(VIM_FILEDIR)     # 当前 buffer 的文件所在路径
# $(VIM_FILEEXT)    File extension of current buffer                        .c                                                  $(VIM_FILEEXT)     # 当前 buffer 的扩展名
# $(VIM_FILETYPE)   File type (value of &ft in vim)                         c
# $(VIM_FILENOEXT)  File name of current buffer without path and extension  json-c-array-add                                    $(VIM_FILENOEXT)   # 当前 buffer 的主文件名(没有前面路径和后面扩展名)
# $(VIM_PATHNOEXT)  Current file name with full path but without extension  /home/wangfuli/json-c-test/json-c-array-add         $(VIM_PATHNOEXT)   # 带路径的主文件名($VIM_FILEPATH 去掉扩展名)
# $(VIM_CWD)        Current directory                                       /home/wangfuli/json-c-test                          $(VIM_CWD)         # 当前 Vim 目录(:pwd 命令返回的)
# $(VIM_RELDIR)     File path relativize to current directory               .                                                   $(VIM_RELDIR)      # 相对于当前路径的文件名
# $(VIM_RELNAME)    File name relativize to current directory               json-c-array-add.c                                  $(VIM_RELNAME)     # 相对于当前路径的文件路径
# $(VIM_CWORD)      Current word under cursor                               stdio                                               $(VIM_CWORD)       # 光标下的单词
# $(VIM_CFILE)      Current filename under cursor                           stdio.h                                             $(VIM_CFILE)       # 光标下的文件名
# $(VIM_CLINE)      Cursor line number in current buffer                    2                                                   $(VIM_CLINE)       # 光标停留在当前文件的多少行(行号)
# $(VIM_VERSION)    Value of v:version                                      802                                                 $(VIM_VERSION)     # Vim 版本号
# $(VIM_SVRNAME)    Value of v:servername for +clientserver usage                                                               $(VIM_SVRNAME)     # v:servername 的值
# $(VIM_COLUMNS)    How many columns in vim's screen                        268                                                 $(VIM_COLUMNS)     # 当前屏幕宽度
# $(VIM_LINES)      How many lines in vim's screen                          53                                                  $(VIM_LINES)       # 当前屏幕高度
# $(VIM_GUI)        Is running under gui ?                                  0                                                   $(VIM_GUI)         # 是否在 GUI 下面运行?
# $(VIM_ROOT)       Project root directory                                  /home/wangfuli/json-c-test                          $(VIM_ROOT)        # 当前 buffer 的项目根目录
# $(VIM_CWDNAME)    Name of current directory                               json-c-test
# $(VIM_PRONAME)    Name of current project root directory                  json-c-test
# $(VIM_DIRNAME)    Directory name of current file                          json-c-test                                         $(VIM_DIRNAME)     # 当前文件夹目录名,比如 vim 在 ~/github/prj1/src,那就是 src
# $(VIM_PROFILE)    Current building profile (debug/release/...)            debug                                               $(VIM_PRONAME)     # 当前项目目录名,比如项目根目录在 ~/github/prj1,那就是 prj1
#### had .git
# Macro             Detail                                                  Value
# $(VIM_FILEPATH)   File name of current buffer with full path              /home/wangfuli/git/cpp-cheat/c/abs.c   $(VIM_FILEPATH)    # 当前 buffer 的文件名全路径
# $(VIM_FILENAME)   File name of current buffer without path                abs.c                                  $(VIM_FILENAME)    # 当前 buffer 的文件名(没有前面的路径)
# $(VIM_FILEDIR)    Full path of current buffer without the file name       /home/wangfuli/git/cpp-cheat/c         $(VIM_FILEDIR)     # 当前 buffer 的文件所在路径
# $(VIM_FILEEXT)    File extension of current buffer                        .c                                     $(VIM_FILEEXT)     # 当前 buffer 的扩展名
# $(VIM_FILETYPE)   File type (value of &ft in vim)                         c
# $(VIM_FILENOEXT)  File name of current buffer without path and extension  abs                                    $(VIM_FILENOEXT)   # 当前 buffer 的主文件名(没有前面路径和后面扩展名)
# $(VIM_PATHNOEXT)  Current file name with full path but without extension  /home/wangfuli/git/cpp-cheat/c/abs     $(VIM_PATHNOEXT)   # 带路径的主文件名($VIM_FILEPATH 去掉扩展名)
# $(VIM_CWD)        Current directory                                       /home/wangfuli/git/cpp-cheat/c         $(VIM_CWD)         # 当前 Vim 目录(:pwd 命令返回的)
# $(VIM_RELDIR)     File path relativize to current directory               .                                      $(VIM_RELDIR)      # 相对于当前路径的文件名
# $(VIM_RELNAME)    File name relativize to current directory               abs.c                                  $(VIM_RELNAME)     # 相对于当前路径的文件路径
# $(VIM_CWORD)      Current word under cursor                               common                                 $(VIM_CWORD)       # 光标下的单词
# $(VIM_CFILE)      Current filename under cursor                           common.h                               $(VIM_CFILE)       # 光标下的文件名
# $(VIM_CLINE)      Cursor line number in current buffer                    9                                      $(VIM_CLINE)       # 光标停留在当前文件的多少行(行号)
# $(VIM_VERSION)    Value of v:version                                      802                                    $(VIM_VERSION)     # Vim 版本号
# $(VIM_SVRNAME)    Value of v:servername for +clientserver usage                                                  $(VIM_SVRNAME)     # v:servername 的值
# $(VIM_COLUMNS)    How many columns in vim's screen                        268                                    $(VIM_COLUMNS)     # 当前屏幕宽度
# $(VIM_LINES)      How many lines in vim's screen                          53                                     $(VIM_LINES)       # 当前屏幕高度
# $(VIM_GUI)        Is running under gui ?                                  0                                      $(VIM_GUI)         # 是否在 GUI 下面运行?
# $(VIM_ROOT)       Project root directory                                  /home/wangfuli/git/cpp-cheat           $(VIM_ROOT)        # 当前 buffer 的项目根目录
# $(VIM_CWDNAME)    Name of current directory                               c
# $(VIM_PRONAME)    Name of current project root directory                  cpp-cheat
# $(VIM_DIRNAME)    Directory name of current file                          c                                      $(VIM_DIRNAME)     # 当前文件夹目录名,比如 vim 在 ~/github/prj1/src,那就是 src
# $(VIM_PROFILE)    Current building profile (debug/release/...)            debug                                  $(VIM_PRONAME)     # 当前项目目录名,比如项目根目录在 ~/github/prj1,那就是 prj1

#### 宏变量展开 #### :AsyncTaskMacro 命令查看
macros['VIM_FILEPATH']  = expand("%:p")                               $(VIM_FILEPATH)    # 当前 buffer 的文件名全路径
macros['VIM_FILENAME']  = expand("%:t")                               $(VIM_FILENAME)    # 当前 buffer 的文件名(没有前面的路径)
macros['VIM_FILEDIR']   = expand("%:p:h")                             $(VIM_FILEDIR)     # 当前 buffer 的文件所在路径
macros['VIM_FILENOEXT'] = expand("%:t:r")                             $(VIM_FILENOEXT)   # 当前 buffer 的主文件名(没有前面路径和后面扩展名)
macros['VIM_PATHNOEXT'] = expand("%:p:r")                             $(VIM_PATHNOEXT)   # 带路径的主文件名($VIM_FILEPATH 去掉扩展名)
macros['VIM_FILEEXT']   = "." . expand("%:e")                         $(VIM_FILEEXT)     # 当前 buffer 的扩展名
macros['VIM_FILETYPE']  = (&filetype)
macros['VIM_CWD']       = getcwd()                                    $(VIM_CWD)         # 当前 Vim 目录(:pwd 命令返回的)
macros['VIM_RELDIR']    = expand("%:h:.")                             $(VIM_RELDIR)      # 相对于当前路径的文件名
macros['VIM_RELNAME']   = expand("%:p:.")                             $(VIM_RELNAME)     # 相对于当前路径的文件路径
macros['VIM_CWORD']     = expand("<cword>")                           $(VIM_CWORD)       # 光标下的单词
macros['VIM_CFILE']     = expand("<cfile>")                           $(VIM_CFILE)       # 光标下的文件名
macros['VIM_CLINE']     = line('.')                                   $(VIM_CLINE)       # 光标停留在当前文件的多少行(行号)
macros['VIM_VERSION']   = ''.v:version                                $(VIM_VERSION)     # Vim 版本号
macros['VIM_SVRNAME']   = v:servername                                $(VIM_SVRNAME)     # v:servername 的值
macros['VIM_COLUMNS']   = ''.&columns                                 $(VIM_COLUMNS)     # 当前屏幕宽度
macros['VIM_LINES']     = ''.&lines                                   $(VIM_LINES)       # 当前屏幕高度
macros['VIM_GUI']       = has('gui_running')? 1 : 0                   $(VIM_GUI)         # 是否在 GUI 下面运行?
macros['VIM_ROOT']      = asclib#path#get_root('%')                   $(VIM_ROOT)        # 当前 buffer 的项目根目录
macros['VIM_HOME']      = expand(split(&rtp, ',')[0])
macros['VIM_PRONAME']   = fnamemodify(macros['VIM_ROOT'], ':t')       $(VIM_PRONAME)     # 当前项目目录名,比如项目根目录在 ~/github/prj1,那就是 prj1
macros['VIM_DIRNAME']   = fnamemodify(macros['VIM_CWD'], ':t')        $(VIM_DIRNAME)     # 当前文件夹目录名,比如 vim 在 ~/github/prj1/src,那就是 src
macros['VIM_PROFILE']   = g:asynctasks_profile
macros['<cwd>']         = macros['VIM_CWD']
macros['<root>']        = macros['VIM_ROOT']
$(VIM_INIFILE)     # 当前任务的 ini 文件名                                               $(VIM_INIFILE)     # 当前任务的 ini 文件名
$(VIM_INIHOME)     # 当前任务的 ini 文件的目录(方便调用一些和配置文件位置相关的脚本)[+]  $(VIM_INIHOME)     # 当前任务的 ini 文件的目录(方便调用一些和配置文件位置相关的脚本)

[project-build]
command=build/my-build-task.sh# 脚本本内部直接用 $VIM_FILENAME 这个环境变量就能取出文件名来,这样通过环境变量传递当前项目/文件信息的方法,结合外部脚本,能让我们定义各种相对复杂的任务,比直接裸写几行 vimscript 的 keymap 强大灵活多了
cwd=<root>

build_out_path=build/$(VIM_FILENOEXT)
build_cpp=g++ $(VIM_FILEPATH) -g -w  -o $(+build_out_path)
build_c=gcc $(VIM_FILEPATH) -g -w  -o $(+build_out_path)
build_cmake=cd build && cmake ../ && cmake --build .
build_xmake=xmake build && xmake
build_rust=cargo check

#### 单个文件的编译运行 #### 编辑/编译/测试                             # :AsyncTaskEdit 编辑当前项目或者当前目录的 .tasks 配置文件
[file-build]                                                            # 定义一个新任务
command=gcc -O2 "$(VIM_FILEPATH)" -o "$(VIM_FILEDIR)/$(VIM_FILENOEXT)"  # 定义任务需要执行的命令,以 `$(...)` 形式出现的宏会在执行时被具体替换
cwd=$(VIM_FILEDIR)                                                      # 定义命令运行的目录
output=quickfix                                                         # 默认模式下,编译错误会和 errorformat 匹配并显示为高亮,方便你按回车跳转到具体错误,或者用 :cnext/:cprev 命令快速跳转错误位置

[file-run]                                                              # 定义一个新任务
command="$(VIM_FILEDIR)/$(VIM_FILENOEXT)"
cwd=$(VIM_FILEDIR)
output=terminal                                                         # 定义输出方式,在终端内运行
# let g:asynctasks_term_pos = 'bottom'
# let g:asynctasks_term_rows = 10    " 设置纵向切割时,高度为 10
# let g:asynctasks_term_cols = 80    " 设置横向切割时,宽度为 80

:AsyncTask file-build                          # 编译当前文件
:AsyncTask file-run                            # 运行当前文件
noremap <silent><f5> :AsyncTask file-run<cr>   # 编译当前文件
noremap <silent><f9> :AsyncTask file-build<cr> # 运行当前文件

#### command 字段支持文件类型过滤 #### 编辑/编译/测试(编译/运行/测试/部署任务) @多语言支持
[file-run]    # 文件类型,文件类型/平台: 注意文件名可能包含空格,所以要双引号 ==> :AsyncTaskMacro
command="$(VIM_FILEPATH)"                  # command 字段支持文件类型过滤
command:c,cpp="$(VIM_PATHNOEXT)"           # command 字段后面加冒号,写明匹配的文件类型,匹配不到的话就会使用最上面的默认命令来执行
command:go="$(VIM_PATHNOEXT)"
command:python=python "$(VIM_FILENAME)"
command:javascript=node "$(VIM_FILENAME)"
command:sh=sh "$(VIM_FILENAME)"
command:lua=lua "$(VIM_FILENAME)"
command:perl=perl "$(VIM_FILENAME)"
command:ruby=ruby "$(VIM_FILENAME)"
output=terminal               # 编译类输出显示到 quickfix 窗口进行匹配; 运行类项目一般设置 output=terminal 选择终端模式,终端模式下有很多不同的运行方式
cwd=$(VIM_FILEDIR)
save=2                                    # 运行前保存所有改动的文件

#### command 字段支持文件类型过滤 #### 编辑/编译/测试(编译/运行/测试/部署任务) @多语言支持
[file-build]                       # 文件类型,文件类型/平台: 注意文件名可能包含空格,所以要双引号 ==> :AsyncTaskMacro
command #    command:c,cpp/win32 : command:c,cpp/linux      ==> 唯一性(根据文件类型和平台) 多实例, 不提供文件类型和平台的command作为默认执行命令
command=echo unsupported filetype $(VIM_FILETYPE)
command:c,cpp/linux=gcc -O2 -Wall -fstrict-aliasing "$(VIM_FILEPATH)" -o "$(VIM_PATHNOEXT)" $(+CFLAGS:) $(+LDFLAGS:) -lstdc++ -lm -msse3 -ldl -lpthread
command=build/my-build-task.sh                      # 外部脚本    : $VIM_FILENAME 文件名                     命令可定制
command=echo hello $(-name), you are a $(-gender).  # 交互式任务  :AsyncTask task1 -name=Batman -gender=boy  命令行参数
$(-prompt:default)                                  # :AsyncTask grep -word=hello
"$(?keyword)"
$(-gender:&male,&female)
$(+var_name)                                        # :AsyncTask project-test  +test_target=mytest
gcc -O2 -Wall "$(VIM_FILEPATH)" -o "$(VIM_PATHNOEXT)" $(+cflags:)   # 给编译器追加动态库和头文件: 如果没定义cflags则为空


#### 整个项目的编译运行 #### 编辑/编译/测试(编译/运行/测试/部署任务) @多语言支持
let g:asyncrun_rootmarks = ['.git', '.svn', '.root', '.project', '.hg'] # 整个项目的编译运行;决定$(VIM_ROOT)和<root>所在目录
[project-build]
command=make
cwd=$(VIM_ROOT)     # 设置在当前项目的根目录处运行 make                 # 如向上搜索到根目录都没找到任何标识,则将当前文件所在目录当作项目根目录

[project-run]
command=make run
cwd=<root>          # <root> 是 $(VIM_ROOT) 的别名,写起来容易些
output=terminal
noremap <silent><f6> :AsyncTask project-run<cr>    # 编译项目
noremap <silent><f7> :AsyncTask project-build<cr>  # 运行项目


#### 任务的优先级 ####
局部配置的优先级高于全局配置,下层目录的配置高于上层目录的配置(.tasks 可以嵌套存在) # PS:可以用 :AsyncTaskEdit 来编辑本地任务,:AsyncTaskEdit! 来编辑全局任务

#### 可用任务查询 ####
可用任务查询 :AsyncTaskList  以点 . 开头的任务名在查询时会被隐藏,使用 :AsyncTaskList! 查看所有任务


#### 多种运行模式 #### let g:asynctasks_term_pos = 'bottom'
名称     | 类型     | 说 明
quickfix | 伪终端   | 默认值,使用 quickfix 窗口模拟终端,输出不匹配 errorformat.
vim      |   -      | 传统 vim 的 ! 命令运行任务,有些人就是迷恋这种方式.
tab      | 内置终端 | 在一个新的 tab 上打开内置终端,运行程序.
TAB      | 内置终端 | 同 tab 但是是在左边打开,关闭后方便回到上一个 tab
top      | 内置终端 | 在上方打开可复用内部终端.
bottom   | 内置终端 | 在下方打开可复用内部终端.
left     | 内置终端 | 在左边打开可复用内置终端.
right    | 内置终端 | 在右边打开可复用内置终端.
external | 外部终端 | 启动一个新的操作系统的外置终端窗口,运行程序.

let g:asynctasks_term_pos = 'bottom'    # 内置终端tab
let g:asynctasks_term_pos = 'tab'       # 内置终端tab
let g:asynctasks_term_pos = 'external'  # 外部终端
let g:asynctasks_term_rows = 10    " 设置纵向切割时,高度为 10
let g:asynctasks_term_cols = 80    " 设置横向切割时,宽度为 80

let g:asynctasks_term_pos = 'external'  # 外部终端; 对于所有 output=terminal 的任务,就能使用外部系统终端了
#### Runner ####    :AsyncTask file-run
[file-run]
command=python "$(VIM_FILEPATH)"
cwd=$(VIM_FILEDIR)
output=terminal
pos=gnome       # let g:asynctasks_term_pos = 'gnome' 全局设置;局部设置

#### 交互式任务 ####    :AsyncTask file-run
[task1]
command=echo hello $(-name), you are a $(-gender).
output=terminal

:AsyncTask task1 -name=Batman -gender=boy # 直接执行;命令行则交互式
提示:使用 $(-prompt:default) 可以提供一个默认值,同时 $(-prompt:) 会记住上次的输入.使用 $(-gender:&male,&female) 来给用户提供备选

[grep]
command=rg -n --no-heading --color never "$(-word)" "<root>" -tcpp -tc -tpy -tvim -tgo -tasm
cwd=$(VIM_ROOT)
errorformat=%f:%l:%m
:AsyncTask grep -word=hello

#### 内部变量 ####    :AsyncTask file-run
[+]                     # .vimrc    配置文件定义 let g:asynctasks_environ = {'foo': '100', 'bar': '200' }
build_target=build_x86  # .task.ini 配置文件定义
test_target=test_x86

[project-build]
command=make $(+build_target)
cwd=<root>

[project-test]
command=make $(+test_target)         # 任何符合 $(+var_name) 的文本都会被替换成星号区域定义的内容; 等价于 make build_x86
cwd=<root>

[project-test]
command=make $(+test_target:testall) # 变量可以有默认值,默认值定义为 $(+变量名:默认值) :
cwd=<root>

低优先级:   全局配置的 [+] 区间.
中优先级:   本地 .tasks 配置的 [+] 区间.
高优先级:   vimscript 的字典变量 g:asynctasks_environ.
最高优先级: 位于 :AsyncTask 任务名 命令后面的 +varname=value 参数.

[file-build]                                                               # [+] 在本地 .tasks 配置中
command=gcc -O2 -Wall "$(VIM_FILEPATH)" -o "$(VIM_PATHNOEXT)" $(+cflags:)  # clags=-g -gprof
cwd=$(VIM_FILEDIR)                                                         # findargs=-tcpp

[project-find]                                                             # [+] 在本地 .tasks 配置中
command=rg -n --no-heading --color never "$(-word)" "<root>" $(+findargs:) # clags=-g -gprof
cwd=$(VIM_ROOT)                                                            # findargs=-tcpp
errorformat=%f:%l:%m

#### 不同 profile 的任务 ####    :AsyncTaskProfile release 或者 let g:asynctasks_profile = 'release'
[task1:release]
command=gcc -O2 "$(VIM_FILEPATH)" -o "$(VIM_PATHNOEXT)"
cwd=$(VIM_FILEDIR)

[task1:debug]
command=gcc -g "$(VIM_FILEPATH)" -o "$(VIM_PATHNOEXT)"
cwd=$(VIM_FILEDIR)


#### demo
[file-buildrun]
command:c,cpp="$(VIM_INIHOME)"/static/cpp-build-run.sh
command:python="$(VIM_INIHOME)"/static/python-cmdargs-run.sh

# F6
[file-build:release]
command=$(VIM_FILENAME)
command:c=gcc -O2 "$(VIM_FILEPATH)" -o "$(VIM_FILEDIR)/build/$(VIM_FILENOEXT)"
command:cpp=g++ -O2 "$(VIM_FILEPATH)" -o "$(VIM_FILEDIR)/build/$(VIM_FILENOEXT)"
cwd="$(VIM_FILEDIR)"
output=quickfix
save=2

[file-build:debug]
command=$(VIM_FILENAME)
command:c=gcc -g "$(VIM_FILEPATH)" -o "$(VIM_FILEDIR)/build/$(VIM_FILENOEXT)"
command:cpp=g++ -g "$(VIM_FILEPATH)" -o "$(VIM_FILEDIR)/build/$(VIM_FILENOEXT)"
cwd="$(VIM_FILEDIR)"
output=quickfix
save=2

# F5
[file-run]
command="$(VIM_FILENAME)"
cwd="$(VIM_FILEDIR)"
output=terminal
save=2

[project-build]
command=make
cwd="$(VIM_ROOT)"
output=quickfix
save=2

[project-run]
command=make
cwd="$(VIM_ROOT)"
output=terminal
save=2


[task1]     ==> let g:asynctasks_system = 'macos'
command=echo default
command/win32=echo win32 default
command/linux=echo linux default
command:c,cpp/win32=echo c/c++ for win32
command:c,cpp/linux=echo c/c++ for linux
command=echo $(VIM:my_name)            # let g:asynctasks_environ = {'my_name': 'Somebody'}


[目标]
file/project
build/run/debug/test/clean
make test/run
grep word/cword
git  push/fetch/pull/

[task1:release]
[task1:debug]
:AsyncTaskProfile release
let g:asynctasks_profile = 'release'
:AsyncTaskProfile debug release


let g:asynctasks_environ = {'foo': '100', 'bar': '200' }
由于同样的变量可以在多处定义,那么他们的优先级是:
    低优先级: 全局配置的 [+] 区间.
    中优先级:本地 .tasks 配置的 [+] 区间.
    高优先级:vimscript 的字典变量 g:asynctasks_environ.
    最高优先级: 位于 :AsyncTask 任务名 命令后面的 +varname=value 参数.


cwd         #  $(VIM_FILEDIR) / $(VIM_ROOT) / <root>          ==> 单实例
output      #  terminal / quickfix                            ==> 单实例 1.quickfix 需要 errorformat 2.quickfix,vim,tab,TAB,top,botton,left,right,external
errorformat # %f:%l:%m / %f(%l):%m
save        #  =2可以在运行前保存所有改动的文件 =1save file before execute
pos         # tab, TAB, bottom, top, left, right, and external
option      # 任意字符串传递给运行程序
focus       # 设置为 0 以防止将焦点切换到任务终端
close       # 设为 1 会在任务完成时关闭任务终端
program     # 命令修改器 :  -program=nice
let g:asyncrun_program = get(g:, 'asyncrun_program', {})        # :AsyncRun -program=nice ls -la ==> nice -5 ls -la
let g:asyncrun_program.nice = { opts -> 'nice -5' . opts.cmd }  # :AsyncRun -program=nice ls -la ==> nice -5 ls -la
notify      # 等值为 true 时,任务完成时会有消息通知,还有很多其他用法、   ==> notify=:call MyTaskFinish()   vimscript
strip       # 设为 1 时,将修剪 quickfix 窗口中的空行和页眉页脚(quickfix only)
scroll      # 设为 0 则禁止快速修复滚动(quickfix only)
encoding    # 任务 stdin/stdout 编码(quickfix only)
once        # 设为 1 可缓冲输出,并在任务完成时刷新,在错误格式中有多行模式时非常有用(quickfix only)

[bottom] top,botton,left,right                                   [tab]                        [external]
let g:asynctasks_term_pos = 'bottom'                             g:asynctasks_term_reuse = 1  let g:asynctasks_term_pos = 'external'
let g:asynctasks_term_rows = 10    " 设置纵向切割时,高度为 10   g:asynctasks_term_focus = 1
let g:asynctasks_term_cols = 80    " 设置横向切割时,宽度为 80

[配置优先级]
~/.vim/tasks.ini
单独给这个项目的 .tasks 局部配置
局部配置的优先级高于全局配置,下层目录的配置高于上层目录的配置(.tasks 可以嵌套存在)
:AsyncTaskList   :AsyncTaskList!

#### 插件设置 ####
let g:asyncrun_open = 6                                                         # 告诉 asyncrun 运行时自动打开高度为 6 的 quickfix 窗口
g:asynctasks_config_name                                                        # 局部配置
let g:asynctasks_config_name = '.asynctask'                                     # 修改默认 .tasks 配置文件的名称
let g:asynctasks_config_name = '.git/tasks.ini'                                 # 修改默认 .tasks 配置文件的名称
let g:asynctasks_config_name = '.tasks,.git/tasks.ini,.svn/tasks.ini'           # 多个本地配置文件,用逗号分隔不同配置名字
let g:asynctasks_config_name = ['.tasks', '.git/tasks.ini', '.svn/tasks.ini']   # 多个本地配置文件,直接用列表

let g:asynctasks_rtp_config = 'tasks.ini'                                       # 修改 ~/.vim 下面的全局配置文件 tasks.ini 的名称

let g:asynctasks_config_name = '.tasks'
let g:asynctasks_config_name = [".tasks", ".git/tasks.ini", ".hg/tasks.ini", ".svn/tasks.ini", ".root/tasks.ini", ".project/tasks.ini"]

g:asynctasks_rtp_config                                                         # 全局配置
let g:asynctasks_rtp_config = "asynctasks.ini"                                  # ~/.vim 下面的全局配置文件 tasks.ini 的名称
g:asynctasks_extra_config                                                       # 额外全局配置
let g:asynctasks_extra_config = [
    \ '~/github/my_dotfiles/my_tasks.ini',
    \ '~/.config/tasks/local_tasks.ini',
    \ ]

g:asynctasks_term_cols   # 内置终端的宽度（使用水平分割时）。
g:asynctasks_term_rows   # 内置终端的高度（使用垂直分割时）。
g:asynctasks_term_focus  # 设置成 0 可以在使用分屏内置终端的时候，避免焦点切换。
g:asynctasks_term_reuse  # 设置成 1 可以复用 tab 类型的内置终端。
g:asynctasks_term_hidden # 设置成 1 的话，所有内置终端的 buffer 会将 bufhidden 初始化成 hide。那么不管你全局有没有设置 hidden，该终端窗口都变成可以隐藏的。
g:asynctasks_template    # 设置成 0 的话,新建配置文件时就不使用模板了
g:asynctasks_confirm     # 设置成 0 的话，使用 :AsyncTaskEdit 时就不需要你确认文件名了。
g:asynctasks_filetype    # 任务配置文件的 filetype，默认值是 "taskini".

## $(VIM_ROOT) 和 <root>
let g:asyncrun_rootmarks = ['.git', '.svn', '.root', '.project', '.hg']         # 整个项目的编译运行
认为该目录是当前项目的根目录,如向上搜索到根目录都没找到任何标识,则将当前文件所在目录当作项目根目录
没有打开文件(未命名新文件窗口):使用 vim 的当前文件夹(即:pwd 返回的值)作为项目目录

############################ 定义一个任务  ############################
# 定义一个新任务
[file-build]
# 定义任务需要执行的命令,以 "$(...)" 形式出现的宏会在执行时被具体替换
command=gcc -O2 "$(VIM_FILEPATH)" -o "$(VIM_FILEDIR)/$(VIM_FILENOEXT)"
# 定义命令运行的目录
cwd=$(VIM_FILEDIR)
# output mode, can be one of quickfix and terminal
# - quickfix: output to quickfix window
# - terminal: run the command in the internal terminal
output=quickfix
# this is for output=quickfix only
# if it is omitted, vim's current errorformat will be used.
errorformat=%f:%l:%m
# save file before execute
save=1       # 0不保存,1保存当前文件2保存所有文件
pos     # tab, TAB, bottom, top, left, right, external, gnome, iterm, floaterm, and tmux
option
focus
close
program
notify
strip
scroll
encoding
once

[project-init]
command=mkdir build && cd build && cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1 .. && ln -s compile_commands.json ..  # 多条命令
cwd=<root>
errorformat=

############################

[file-run]
command="$(VIM_FILEDIR)/$(VIM_FILENOEXT)"
cwd=$(VIM_FILEDIR)
# 定义输出方式,在终端内运行
output=terminal


# task from defaults
[file-build]
# shell command, use quotation for filenames containing spaces
# check ":AsyncTaskMacro" to see available macros
command=gcc "$(VIM_FILEPATH)" -o "$(VIM_FILEDIR)/$(VIM_FILENOEXT)"
# working directory, can change to $(VIM_ROOT) for project root
cwd=$(VIM_FILEDIR)
# output mode, can be one of quickfix and terminal
# - quickfix: output to quickfix window
# - terminal: run the command in the internal terminal
output=quickfix
# this is for output=quickfix only
# if it is omitted, vim's current errorformat will be used.
errorformat=%f:%l:%m
# save file before execute
save=1


[file-build]
# macros in the "$(...)" form will be substituted,
# shell command, use quotation for filenames containing spaces
command=gcc -O2 "$(VIM_FILEPATH)" -o "$(VIM_FILEDIR)/$(VIM_FILENOEXT)"
# working directory
cwd=$(VIM_FILEDIR)

[file-run]
command="$(VIM_FILEDIR)/$(VIM_FILENOEXT)"
cwd=$(VIM_FILEDIR)
# output mode: run in a terminal
output=terminal



~/.config/asynctask/tasks.ini  # for asynctask -f like fzf-cheatsheet

[git-push-master]
command=git push origin master

[git-pull-master]
command=git pull origin master

[git-fetch-master]
command=git fetch origin master

[git-checkout]
command=git checkout $(?branch)

[git-proxy-on]
command=git config --global http.proxy "socks5://localhost:1080" && git config --global https.proxy "socks5://localhost:1080"

[git-proxy-off]
command=git config --global --unset http.proxy && git config --global --unset https.proxy

[git-status]
command=git status

[git-log]
command=tig

[misc-supervisor-reload]
command=sudo supervisorctl reload

[misc-weather]
command=curl -s wttr.in/?n0

[misc-benchmark-cpu]
command=python -c "import test.pystone;print(test.pystone.pystones(500000))"

[misc-benchmark-mem]
command=dd if=/dev/zero of=/dev/null bs=1M count=32768

[misc-disk-usage]
command=df -h

[misc-system-info]
command=neofetch

[misc-create-qr-code]
command=echo '$(?content)' | curl -F-=\<- qrenco.de

[net-check-port]
command=sudo lsof -i :$(?port)

[net-host-ip]
command=hostname --all-ip-addresses | tr " " "\n" | grep -v "0.0.0.0" | grep -v "127.0.0.1"
command/darwin=ifconfig  | grep -E 'inet.[0-9]' | grep -v '127.0.0.1' | awk '{ print $2}'

[net-start-http]
command=python -m SimpleHTTPServer $(?port)

[net-whois-domain]
command=/usr/bin/whois -h whois.internic.net $(?domain) | sed '/NOTICE:/q'

[ssh-qn1]
command=ssh qn1.skywind.me

[ssh-11]
command=ssh 192.168.1.11

[ssh-10]
command=ssh 192.168.1.10

[ssh-12]
command=ssh 192.168.1.12

[ssh-3]
command=ssh 192.168.1.3






[shfmt]
command=shfmt -w -i 2 -p "$(VIM_FILEPATH)"
output=quickfix
save=1
notify=:edit


[file-build-run]
command:c=gcc -std=c11 -g -Wall "$(VIM_FILEPATH)" -o "$(VIM_PATHNOEXT)" && $(+wrapper_cpp:) "$(VIM_PATHNOEXT)"
command:cpp=g++ -std=c++17 -g -Wall -fsanitize=address -fno-omit-frame-pointer "$(VIM_FILEPATH)" -o "$(VIM_PATHNOEXT)" && $(+wrapper_cpp:) "$(VIM_PATHNOEXT)"
command:go=go build -o "$(VIM_PATHNOEXT)" "$(VIM_FILEPATH)" && "$(VIM_PATHNOEXT)"
command:rust=rustc "$(VIM_FILEPATH)" -o "$(VIM_PATHNOEXT)" && "$(VIM_PATHNOEXT)"
cwd=$(VIM_FILEDIR)
output=terminal
save=2