# Fig pre block. Keep at the top of this file.
# [[ -f "$HOME/.fig/shell/bashrc.pre.bash" ]] && builtin source "$HOME/.fig/shell/bashrc.pre.bash"
# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# If not running interactively, don't do anything
case $- in
    *i*) ;;
    *) return;;
esac

# don't put duplicate lines or lines starting with space in the history.
# See bash(1) for more options
# HISTCONTROL=ignoreboth
export HISTCONTROL='ignoredups:erasedups'

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=100000
HISTFILESIZE=200000

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# If set, the pattern "**" used in a pathname expansion context will
# match all files and zero or more directories and subdirectories.
#shopt -s globstar

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color|*-256color) color_prompt=yes;;
esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
#force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
        # We have color support; assume it's compliant with Ecma-48
        # (ISO/IEC-6429). (Lack of such support is extremely rare, and such
        # a case would tend to support setf rather than setaf.)
        color_prompt=yes
    else
        color_prompt=
    fi
fi

if [ "$color_prompt" = yes ]; then
    PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
else
    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
fi
unset color_prompt force_color_prompt

# If this is an xterm set the title to user@host:dir
case "$TERM" in
    xterm*|rxvt*)
        PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
        ;;
    *)
        ;;
esac

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# colored GCC warnings and errors
#export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'

# some more ls aliases
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'

# Add an "alert" alias for long running commands.  Use like so:
#   sleep 10; alert
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n 1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'

# Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.

if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if ! shopt -oq posix; then
    if [ -f /usr/share/bash-completion/bash_completion ]; then
        . /usr/share/bash-completion/bash_completion
    elif [ -f /etc/bash_completion ]; then
        . /etc/bash_completion
    fi
fi

export GIT_SSL_NO_VERIFY=1  # 忽略git认证

#  make bash save commands to the history file in realtime
shopt -s histappend
PROMPT_COMMAND="history -a;$PROMPT_COMMAND"

pipe(){
  exval=1
  while IFS= read -t 0.1 -r line; do
    echo "$line"
    exval=0
  done
  return "$exval"
}

alias cduser=svnuser
alias cdqsdk=svnqsdk
svnqsdk(){
  local oldpwd=$(pwd)
  while ! [ -d .svn ]; do
    cd ../
  done
  [ -d qsdk ] && cd $(pwd)/qsdk
  [ -n $1 ] && eval "$@"

  which zoxide 2>&1 > /dev/null && zoxide add $(pwd)

  OLDPWD=${oldpwd}
}
# eval "$(lua /home/wangfuli/git/z.lua/z.lua  --init bash once enhanced)"   # BASH 初始化

alias sourcebash='source ~/.bashrc'
alias sourcetmux='tmux source-file ~/.tmux.conf'

alias resovl='sudo cp /etc/resolv.conf.bak /etc/resolv.conf'

alias makee='make 2>&1 | tee ./makeerror.log | grep error'   # tmuxpaste
alias makew='make 2>&1 | tee ./makewarn.log  | grep warning' # tmuxpaste
alias makes='make -j$(nproc) V=1 QUILT=1'                    # tmuxpaste
alias makev='make -j1 V=sc'                                  # tmuxpaste

# make  package/kernel/mac80211 clean ==> /logs/package/kernel/mac80211/compile.txt
alias makekconfig='make -j$(nproc) kernel_menuconfig '         # CONFIG_TARGET=subtarget
alias makekclean='cdqsdk; make -j$(nproc) target/linux/clean;' # rm -rf build_dir/target-*/linux-*
alias makek='cdqsdk; make target/linux/compile; make package/kernel/linux/compile'
alias makekv='cdqsdk; make target/linux/compile -j1 V=scw; make package/kernel/linux/compile -j1 V=scw'

# make target/linux/clean   V=s  # kernel clean
# make target/linux/prepare V=s  # kernel prepare
# make target/linux/refresh V=s  # kernel refresh
# make target/linux/compile V=s  # kernel compile
# make target/linux/install V=s  # kernel install

# mkpkg ; mkpkg clean; mkpkg compile; mkpkg prepare; mkpkg configure
mkpkg() {
  local oldpwd="$(pwd)"
  svnqsdk
  local dir
  local cmd
  dir=$(find -L package/ -name Makefile | xargs dirname | grep -v 'src\|kernel\|boot' | fzf -0 -1 +m)
  [ -n "$dir" ] && dir=$(basename "$dir")
  [ -n "$dir" ] && {
    package=$(basename "$dir")
    [ "$#" -ge 1 ] && [ -n "$1" ] && {
      cmd="$1"
      shift
    }

    if [[ -n "$cmd" ]]; then
      make "package/$package/$cmd" -j1 V=scw $@
      echo "make package/$package/$cmd -j1 V=scw $*"
    else
      make package/"$package"/{clean,compile} -j1 V=scw
      echo "make package/$package/{clean,compile} -j1 V=scw"
    fi
    __last_cdp="$package"
  }
  cd "$oldpwd" || return
}

# mkmod;  mkmod clean;   mkmod compile
mkmod() {
  local oldpwd="$(pwd)"
  svnqsdk
  local dir
  local cmd
  dir=$(find -L package/kernel/ -maxdepth 1 -type d | fzf -0 -1 +m)
  [ -n "$dir" ] && {
    module=$(basename "$dir")
    [ "$#" -ge 1 ] && [ -n "$1" ] && {
      cmd="$1"
      shift
    }

    if [ -n "$cmd" ]; then
      make "package/kernel/$module/$cmd" -j1 V=scw $@
      echo "make package/kernel/$module/$cmd -j1 V=scw $*"
    else
      make package/kernel/"$module"/{clean,compile} -j1 V=scw
      echo "make package/kernel/$module/{clean,compile} -j1 V=scw"
    fi
  }
  cd "$oldpwd" || return
}

# mkqsdk make menuconfig # reduce fzf interactive @openwrt
mkqsdk() {
  local oldpwd=$(pwd)
  cdqsdk
  (eval "$@")
  cd "$oldpwd" || return
}

# mkuser    # reduce fzf interactive @sdk
mkuser() {
  local oldpwd=$(pwd)
  cduser
  local dir

  [ "$#" -ge 1 ] && [ -n "$1" ] && {
      dir="$1"
      shift
  }
  [ -d "$dir" ] || dir=$(find . -maxdepth 1 -type d | fzf -0 -1 +m)
  [ -d "$dir" ] && (
    cd "$dir" || return
    make "$@"
    echo "=============== put command or library to /ftptmp ==============="
    put $(find -type f | xargs file 2>&1 | grep linked | awk -F ':' '{print $1}')
  )
  basename "$dir"
  cd "$oldpwd" || return
}

# put linked library or execute binary file
put_bin(){
  put $(find -type f | xargs file 2>&1 | grep linked | awk -F ':' '{print $1}')
}

# mksdk systemconf # reduce fzf interactive @sdk
mksdk() {
  local oldpwd=$(pwd)
  cduser
  [ "$#" -ge 1 ] && [ -d "$1" ] && {
      dir="$1"
      shift
  } || {
    dir=$(find . -maxdepth 1 -type d | fzf -0 -1 +m)
  }
  eval "cd $dir; make $@"
  echo "=============== put command or library to /ftptmp ==============="
  put $(find -type f | xargs file 2>&1 | grep linked | awk -F ':' '{print $1}')
  cd "$oldpwd" || return
}

makekm() { # depreciated; replace by mkmod
  local oldpwd=$(pwd)
  local module
  [ -z "$1" ] && module=$(
    cdqsdk
    ls package/kernel | fzf
  ) || module="$1"
  [ -d build_dir ] || cdqsdk

  make package/kernel/"$module"/{clean,compile} -j1 V=scw
  echo "make package/kernel/$module/{clean,compile} -j1 V=scw"
  cd $oldpwd
}


makevv(){ # depreciated; need PRODUCT_DIR=MR890H-N PRODUCT_HARDWARE_VERSION=MR890 environment variable
    local output="make.${RANDOM}"
    make -j1 V=scw $@ 2>&1 | tee $output
    echo "vim $output"
}

gitc(){ # init a c git project
    [ -d .git ] && return
    git config user.name "wangfuli"
    git config user.email "wangfl217@126.com"
    git init
    cp /home/wangfuli/git/gitignore/C.gitignore ./.gitignore
    git add *
}

# 删除文件末尾128位签名
# dd if=KF_Image bs=1 count=6408390 of=orig
ubin_orig(){
  [ "$#" -ne 0 ] && [ -f $1 ] && {
    filesize=$(stat -c "%s" $1)
    filesize=$((filesize-128))
    dd if=$1 bs=1 count=$filesize of=$1.orig
    echo "$1.orig is unsign ubin"
  } || {
    echo "$# specify filename"
  }
}

ubin_digital(){
  [ "$#" -ne 0 ] && [ -f $1 ] && {
    filesize=$(stat -c "%s" $1)
    filesize=$((filesize-128))
    dd if=$1 bs=1 skip=$filesize count=128 of=$1.digit
    echo "$1.digit is signature information(digital signature)"
  } || {
    echo "$# specify filename"
  }
}

ubin_sign(){
  which verSignature >/dev/null 2>&1 ||  { echo "verSignature command is not exist"; return 1; }
  [ -f cakey.pem ] || cp /home/wangfuli/versign/cakey.pem .
  if [ "$#" -eq 0 ]; then
    for fl in ./*.ubin ; do
      cp $fl $fl.orig
      verSignature sign $fl /home/wangfuli/versign/cakey.pem
    done
  else
    cp $1 $1.orig
    verSignature sign $1 /home/wangfuli/versign/cakey.pem
  fi
  [ -f cakey.pem ] && rm -f cakey.pem
}

ubin_assert(){
  which verSignature >/dev/null 2>&1 ||  { echo "verSignature command is not exist"; return 1; }
  [ -f cakey.pem ] || cp /home/wangfuli/versign/cakey.pem .
  if [ "$#" -eq 0 ]; then
    for fl in ./*.ubin ; do
      verSignature verify $fl /home/wangfuli/versign/pubkey.pem
    done
  else
    cp $1 $1.orig
    verSignature verify $1 /home/wangfuli/versign/pubkey.pem
  fi
  [ -f pubkey.pem ] && rm -f pubkey.pem
}

ubin_bin_step=1
alias ubin_dir='mkdir $(date "+%a")$((ubin_bin_step++))_$(date "+ubin_%Y%m%d_%H%M%S")'
ubin_bin(){
    local suffix=$(date "+ubin_%Y%m%d_%H%M%S")
    local prefix=$(date "+%a")
    bindir="${prefix}$((ubin_bin_step++))_${suffix}"
    mkdir $bindir
    cp KF_Image $bindir
    local newbin=$(ls -dlt *Build* | grep '^d' | head -n 1 | awk '{print $NF}')
    mv ${newbin}/* $bindir
    rmdir ${newbin}
}

put_ubin(){ # put newest ubin to /ftptmp
  local oldpwd=$(pwd)
  [ -d images ] && {
    newdir=$(ls -dlt images/*Build* | grep '^d' | head -n 1 | awk '{print $NF}')
  } || {
    stat *-Buildx*  > /dev/null 2>&1 || { cdproject; [ -d images ] && cd images; }
    newdir=$(ls -dlt *Build* | grep '^d' | head -n 1 | awk '{print $NF}')
  }

  # echo "$newdir"/*.ubin
  [ "$(uname)" = "Linux" ] && {
    put "$newdir"/*.ubin
  } || {
    cp "$newdir"/*.ubin /ftptmp
  }
  cd ${oldpwd}
}
put_rbin(){ # put newest rbin to /ftptmp
  local oldpwd=$(pwd)
  [ -d images ] && {
    newdir=$(ls -dlt images/*Build* | grep '^d' | head -n 1 | awk '{print $NF}')
  } || {
    stat *-Buildx*  > /dev/null 2>&1 || { cdproject; [ -d images ] && cd images; }
    newdir=$(ls -dlt *Build* | grep '^d' | head -n 1 | awk '{print $NF}')
  }

  # echo "$newdir"/*.rbin
  [ "$(uname)" = "Linux" ] && {
    put "$newdir"/*.rbin
  } || {
    cp "$newdir"/*.rbin /ftptmp
  }
  cd ${oldpwd}
}
put_KF(){ # put newest KF_Image to /ftptmp
  local oldpwd=$(pwd)
  [ -d images ] && {
    newdir=$(pwd)/images
  } || {
    stat *-Buildx*  > /dev/null 2>&1 || { cdproject; [ -d images ] && cd images; }
    newdir=$(pwd)
  }

  [ "$(uname)" = "Linux" ] && {
    put "$newdir"/KF_Image
  } || {
    cp "$newdir"/KF_Image /ftptmp
  }
  cd ${oldpwd}
}

put_img(){ # put newest img or cpio.lzma to /ftptmp
  local oldpwd=$(pwd)
  cdqsdk

  [ -d build_dir ] && {
    test -f bin/*/openwrt-*-squashfs-root.img && {
        # echo bin/*/openwrt-*-squashfs-root.img
        put $(find bin -name "*squashfs*root.img")
    }
    find  bin/targets/ramips/ -name "*.bin" > /dev/null 2>&1 && {
        # echo bin/targets/ramips/*/*.bin
        put bin/targets/ramips/*/*.bin
    }
  }

  [ -d source ] && {
    # echo source/linux-*/usr/initramfs_data.cpio.lzma
    put source/linux-*/usr/initramfs_data.cpio.lzma
  }

  cd ${oldpwd}
}

put_pkg() { # put pkg include executable file
  local oldpwd=$(pwd)
  [ -d build_dir ] || { svnqsdk; }

  local cdb_var="$1"
  [ "$#" = "0" ] && [ -n "$__last_cdb" ] && { cdb_var=$__last_cdb; }
  [ -z "$cdb_var" ] && {
    cd build_dir
    return
  }

  cd build_dir/target-*/${cdb_var}*
  put $(file * 2>&1 | grep linked | awk -F ':' '{print $1}')
  export __last_cdb="$cdb_var"
  export __last_cdp="$cdb_var"
  cd ${oldpwd}
}

put_opkg() { # put put_opkg file
  local oldpwd=$(pwd)
  [ -d build_dir ] || { svnqsdk; }
  cd bin
  put $(fzf)
  cd ${oldpwd}
}

putx() {
rm -rf /mnt/hgfs/ftptmp/code/*
putc *.c *.h Makefile
}
getx() {
getc *.c *.h Makefile
rm -rf /mnt/hgfs/ftptmp/code/*
}

makeromfs(){
# export CROSS_COMPILE=/opt/buildroot-gcc463/usr/bin/mipsel-linux-
# export CC=${CROSS_COMPILE}gcc
# in subshell; AR..ROMFSINST are not export
(
export AR="/opt/buildroot-gcc463/usr/bin/mipsel-linux-ar"
export CC="/opt/buildroot-gcc463/usr/bin/mipsel-linux-gcc"
export CPP="/opt/buildroot-gcc463/usr/bin/mipsel-linux-cpp"
export LD="/opt/buildroot-gcc463/usr/bin/mipsel-linux-ld"
export RANLIB="/opt/buildroot-gcc463/usr/bin/mipsel-linux-ranlib"
export STRIP="/opt/buildroot-gcc463/usr/bin/mipsel-linux-strip"
current=$(pwd)
export ROMFSDIR="${current%%user*}/romfs"
export ROMFSINST="${current%%user*}/tools/romfs-inst.sh"
make romfs
)
}

alias cdbin='svnbin'
svnbin(){
  local oldpwd=$(pwd)
  ls -tld *-ZHCN* > /dev/null 2>&1 && {
    cd $(ls -tld *-ZHCN* | head -n 1 | awk '{print $NF}')
    OLDPWD=${oldpwd}
  }
  ls -tld ./images/*-ZHCN* > /dev/null 2>&1 && {
    cd $(ls -tld ./images/*-ZHCN* | head -n 1 | awk '{print $NF}')
    OLDPWD=${oldpwd}
  }

  which zoxide 2>&1 > /dev/null && zoxide add $(pwd)

}

alias cdromfs=svnromfs
svnromfs(){
  local oldpwd=$(pwd)
  while ! [ -d .svn ]; do
    cd ../
  done
  [ -d "$(pwd)/source/romfs/" ] && cd $(pwd)/source/romfs/
  [ -n $1 ] && eval "$@"
  OLDPWD=${oldpwd}

  which zoxide 2>&1 > /dev/null && zoxide add $(pwd)
}

svnuser(){
  local oldpwd=$(pwd)
  while ! [ -d .svn ]; do
    cd ../
  done
  [ -d "$(pwd)/source/user/" ] && cd $(pwd)/source/user/
  [ -n $1 ] && eval "$@"
  OLDPWD=${oldpwd}

  which zoxide 2>&1 > /dev/null && zoxide add $(pwd)
}

put_user() {
  local oldpwd=$(pwd)
  while ! [ -d .svn ]; do
    cd ../
  done
  [ -d "$(pwd)/source/user/" ] && cd $(pwd)/source/user/
  local pkgdir
  [ -n "$1" ] && pkgdir="$1" || pkgdir=$(find -maxdepth 1 -type d | fzf)
  [ -n "$pkgdir" ] && (
    cd "$pkgdir"
    [ -d src ] && cd src
    put $(file * 2>&1 | grep linked | awk -F ':' '{print $1}')
  )
  cd "$oldpwd"
  OLDPWD=${oldpwd}
}

alias cdproduct=svnproduct
svnproduct(){
  local oldpwd=$(pwd)
  while ! [ -d .svn ]; do
    cd ../
  done
  product=$(find $(pwd)/product -maxdepth 1 -type d | fzf)
  [ -n "$product" ] && cd "$product"
  OLDPWD=${oldpwd}
}

alias _cdproduct=_svnproduct
_svnproduct(){
  local oldpwd=$(pwd)
  while ! [ -d .svn ]; do
    cd ../
  done
  [ -d "$(pwd)/product" ] && cd $(pwd)/product
  OLDPWD=${oldpwd}
  which zoxide 2>&1 > /dev/null && zoxide add $(pwd)
}

alias cdroot=svnroot
svnroot(){
  local oldpwd=$(pwd)
  while ! [ -d .svn ]; do
    cd ../
  done
  [ -n $1 ] && eval "$@"
  OLDPWD=${oldpwd}
  which zoxide 2>&1 > /dev/null && zoxide add $(pwd)
}

_gitroot() {
    git rev-parse --show-toplevel
}
cdgit() {
  cd "$(_gitroot)/${1:-}";
  [ -n $1 ] && eval "$@"
  which zoxide 2>&1 > /dev/null && zoxide add $(pwd)
}


alias cdqsdk=svnqsdk
svnqsdk(){
  local oldpwd=$(pwd)
  while ! [ -d .svn ]; do
    cd ../
  done
  [ -d qsdk ] && cd $(pwd)/qsdk
  [ -n $1 ] && eval "$@"
  OLDPWD=${oldpwd}
  which zoxide 2>&1 > /dev/null && zoxide add $(pwd)
}

alias cdpackage=svnpackage
alias cdpkg=svnpackage
svnpackage(){
  local oldpwd=$(pwd)
  while ! [ -d .svn ]; do
    cd ../
  done
  [ -d qsdk ] && cd $(pwd)/qsdk
  [ -d package ] && cd package
  [ -n $1 ] && eval "$@"
  OLDPWD=${oldpwd}
  which zoxide 2>&1 > /dev/null && zoxide add $(pwd)
}

alias project='export __project=$(pwd)'
cdproject(){
  local oldpwd=$(pwd)
  [ -n "$__project" ] && cd ${__project} || {
    _cdproduct
    local project_var=$(ls -dlt * | grep '^d' | head -n 1 | awk '{print $NF}')
    [ -n "project_var" ] && [ -d "$(pwd)/$project_var" ] && {
      cd $(pwd)/$project_var;
    }
  }

  which zoxide 2>&1 > /dev/null && zoxide add $(pwd)

  OLDPWD=${oldpwd}
  which zoxide 2>&1 > /dev/null && zoxide add $(pwd)
}

export project_user_mk_arg=  # '-j1 V=s'

# s: stdout+stderr        (equal to the old V=99) V=99 OPENWRT_VERBOSE:=s
# c: commands (for build systems that suppress commands by default,e.g. kbuild,cmake)
# w: warnings/errors only (equal to the old V=1)  V=1  OPENWRT_VERBOSE:=w
mklaste() {
  local oldpwd=$(pwd)
  [ -d build_dir ] || cdqsdk
  __last_cdp=$1
  shift
  method=$(echo -e "compile\nprepare\nconfigure\ninstall\nclean\nrefresh\nupdate\ndownload\ncheck\nkernel_menuconfig\nmenuconfig\nclean\ntargetclean\ndirclean\nkernel_clean\nkernel_build\n" | fzf)
  if [ "$method" = "kernel_menuconfig" ]; then
    make kernel_menuconfig
  elif [ "$method" = "menuconfig" ]; then
    make menuconfig
  elif [ "$method" = "clean" ]; then
    make clean
  elif [ "$method" = "targetclean" ]; then
    make targetclean
  elif [ "$method" = "dirclean" ]; then
    make dirclean
  elif [ "$method" = "kernel_clean" ]; then
    make target/linux/clean; make package/kernel/linux/clean
  elif [ "$method" = "kernel_build" ]; then
    make target/linux/compile -j1 V=scw; make package/kernel/linux/compile -j1 V=scw
  else
    make package/"$__last_cdp"/"$method" -j1 V=scw $@ # -j1 V=scw
  fi
  cd $oldpwd
}

mklast() {
  local verbose
  local cmd
  local fuzzysel
  while getopts ':vxc:h' x; do
    case "$x" in
      v) verbose="1" ;;
      x) fuzzysel="1" ;;
      c) cmd=${OPTARG} ;;
      h | *)
        echo "mklast [-v|verbose] [-x|fuzzysel cmd] [-c|specified cmd] package"
        echo "mklast          netifd" # {clean,compile}
        echo "mklast -v       netifd" # {clean,compile} -j1 V=scw
        echo "mklast -x       netifd" # command selected  by fzf
        echo "mklast -c clean netifd" # command specified by user
        return
        ;;
    esac
  done
  shift $((OPTIND - 1))
  unset x OPTARG OPTIND

  local oldpwd=$(pwd)
  [ -d build_dir ] || cdqsdk
  [ -n "$1" ] && {
    __last_cdp="$1"
    __last_cdb="$1"
  }

  [ -n "$2" ] && {
    cmd="$2"
    shift
    shift
  }
  [ -n "$verbose" ] && verbose="-j1 V=scw"

  [ -n "$fuzzysel" ] && {
    mklaste "$__last_cdp"
    cd "$oldpwd"
    return
  }
  [ -n "$__last_cdp" ] && {
    if [[ -n $cmd ]]; then
      make package/"$__last_cdp"/"$cmd" $verbose $@
    else
      make package/"$__last_cdp"/{clean,compile} $verbose
    fi
  }
  cd $oldpwd
}

mklastv() {
  local oldpwd=$(pwd)
  [ -d build_dir ] || cdqsdk
  [ -n "$1" ] && {
    __last_cdp="$1"
    __last_cdb="$1"
  }

  [ -n "$2" ] && {
    cmd="$2"
    shift
    shift
  }

  [ -n "$__last_cdp" ] && {
    if [ -n "$cmd" ]; then
      make package/"$__last_cdp"/"$cmd" -j1 V=s $@
    else
      make package/"$__last_cdp"/{clean,compile} -j1 V=s
    fi
  }
  cd $oldpwd
}

mklastp(){
  mklastv "$@"
  echo "=============== put $@ to /ftptmp ==============="
  put_pkg "$@"
}

mklastq() {
  local oldpwd=$(pwd)
  [ -d build_dir ] || cdqsdk
  [ -n "$1" ] && {
    __last_cdp="$1"
    __last_cdb="$1"
  }

  [ -n "$__last_cdp" ] && make package/"$__last_cdp"/compile -j1 V=s
  cd $oldpwd
}

project_env(){
  local makecmd=$(grep PRODUCT_DIR mkall.sh | grep -v echo)
  makecmd=${makecmd##*PRODUCT_DIR}

  [ -n "$makecmd" ] || {
    local makecmd=$(grep PDIR mkall.sh | grep -v echo)
    makecmd=${makecmd##*PDIR}
    makecmd=PDIR${makecmd}
  } && {
    makecmd=PRODUCT_DIR${makecmd}
  }
  echo "project_mk_arg=${makecmd}"
  export project_mk_arg=${makecmd}
}

mkall(){
  local oldpwd=$(pwd)

  while ! [ -d .svn ]; do
    cd ../
  done

  local product_path
  [ -n "$1" ] && product_path="$(pwd)/product/$1" || product_path=$(find $(pwd)/product -maxdepth 1 -type d | fzf)
  [ -d "$product_path" ] && {
    cd "$product_path"
    [ "$#" = "0" ] && { ./mkall.sh zh; export PRODUCT_DIR=$(basename $(pwd)); project_env; echo "mkall $(basename $product_path)"; } || \
    { ./mkall.sh ; export PRODUCT_DIR=$(basename $(pwd)); project_env; echo "mkall $(basename $product_path)"; };
  }
  echo "=============== put ubin to /ftptmp ==============="
  put_ubin
  cd ${oldpwd};
}

md5k(){ # tftp升级
  ls KF_Image > /dev/null 2>&1 && {
    md5sum KF_Image
  }

  cdproject;
  ls images/KF_Image > /dev/null 2>&1 && {
    md5sum images/KF_Image
  }
  ls /mnt/hgfs/ftptmp/KF_Image > /dev/null 2>&1 && {
    md5sum /mnt/hgfs/ftptmp/KF_Image
  }
}
md5u(){ # web升级
  ls *.ubin > /dev/null 2>&1 && {
    md5sum *.ubin
  }
  ls /mnt/hgfs/ftptmp/*.ubin > /dev/null 2>&1 && {
    md5sum /mnt/hgfs/ftptmp/*.ubin
  }
}
md5r(){ # 工厂升级
  ls *.rbin > /dev/null 2>&1  && {
    md5sum *.rbin
  }
  ls /mnt/hgfs/ftptmp/*.rbin > /dev/null 2>&1 && {
    md5sum /mnt/hgfs/ftptmp/*.rbin
  }
}

# default cd to last build_dir feeds
# cdb configmanage
cdb(){
  local oldpwd=$(pwd)
  [ -d build_dir ] || { svnqsdk; }

  local cdb_var="$1"

  if [[ "$cdb_var" = "fzf" || -z "$cdb_var" ]]; then
     dir=$(find build_dir/target-* -maxdepth 1 -type d | fzf -0 -1 +m)
     [ -n "$dir" ] && [ -d "$dir" ] && cd "$dir"
  else
    cd build_dir/target-*/${cdb_var}*
  fi

  eval xsync
  OLDPWD=${oldpwd}
}

# default cd to last package feeds
# cdp configmanage
cdp(){
  local oldpwd=$(pwd)
  [ -d package ] || { svnqsdk; }

  local cdp_var="$1"

  cd package
  if [[ "$cdp_var" = "fzf" || -z "$cdp_var" ]]; then
    dir=$(find -L -name Makefile | xargs dirname | grep -v 'src\|kernel\|boot' | fzf -0 -1 +m )
    [ -n "$dir" ] && [ -d "$dir" ] && cd "$dir"
  else
    cd $(find -L -maxdepth 4 -type d -name "*$cdp_var*" | head -n 1)
  fi

  [ -d src ] && { cd src; eval xsync; }
  eval xsync
  OLDPWD=${oldpwd}
}

cdrootfs(){
  local oldpwd=$(pwd)
  [ -d build_dir ] || { svnqsdk; }
  cd build_dir/target-*/linux-*/base-files/ipkg-*/base-files
  [ -n $1 ] && eval "$@"

  which zoxide 2>&1 > /dev/null && zoxide add $(pwd)

  OLDPWD=${oldpwd}
}

cross_path_arm(){
  local oldpwd=$(pwd)
  [ -d build_dir ] || cdqsdk
  cd staging_dir/toolchain-aarch*/bin/
  local cross_path=$(pwd)
  cd -

  PATH=${cross_path}:${PATH}
  export PATH
  ls ${cross_path}
  cd $oldpwd
}

cross_path_mips(){
  local oldpwd=$(pwd)
  [ -d build_dir ] || cdqsdk
  cd staging_dir/toolchain-mips*/bin/
  local cross_path=$(pwd)
  cd -

  PATH=${cross_path}:${PATH}
  export PATH
  ls ${cross_path}
  cd $oldpwd
}
export PATH=/snap/bin/:${PATH}
export PATH=/home/wangfuli/.vim/bin/:${PATH}
#
# cdp(){
# local t=$(pwd)
# cd $__old_dir
# export __old_dir=${t}
# }

alias cdftp='cd /mnt/hgfs/ftptmp/'
#[c]
indentlen='wc -L $@'
indentwfl(){
  dos2unix "$@"
  indent -kr -i4 -ts4 -sob -ss -sc -npsl -pcs -bs --ignore-newlines -l200 -nut -npro -brf -nbbo "$@"
}

indentyc(){
  for f in $@; do
    count=$(wc -L $f | awk '{print $1}')
    dos2unix $f
    sed -i 's/\s*$//g' $f;
    indent -kr -i4 -ts4 -sob -ss -sc -npsl -pcs -bs --ignore-newlines -l${count} -nut -npro -brf -nbbo $f
  done
}

indentycc(){
  indentyc *.c
  indentyc *.h
}

alias exptab="perl -pi -e 's/\t/ q( ) x ( 4 - pos() %4 ) /ge' "
alias cppcheckwfl='cppcheck --std=c99 --enable=warning,style -v '
#[bash]
alias shfmt='shfmt -l -w -i 2 -ci'
alias shfmt2='shfmt -l -w -i 2 -ci'
alias shfmt4='shfmt -l -w -i 4 -ci'
# shellcheck

alias tclsh='rlwrap tclsh'
alias lua="rlwrap -Ar -pcyan --always-readline lua"
alias iperl='rlwrap -A -S "iperl> " perl -MData::Printer -wnE '\'' BEGIN { say "HI"; } say eval()//$@'\' # sudo cpan Data::Printer 有返回值回显1
alias vi='vim -u ~/.vimrc-backup'

# ntpdate -s time.nist.gov

alias xsync='pwd > /mnt/hgfs/ftptmp/xsync'
alias eu='pwd > /mnt/hgfs/ftptmp/xsync'

alias psmem10='ps auxf | sort -nr -k 4 | head -n 10'
alias pscpu10='ps auxf | sort -nr -k 3 | head -n 10'

# Syntax: "repeat_ok [command]"
repeat_ok()  { while :; do "$@" && return; done }
# Syntax: "repeat_err [command]"
repeat_err() { while :; do "$@" || return; done }
# Syntax: "repeat_sleep <timeout> <command>"
repeat_sleep() { timeout=$1; shift; while :; do "$@" && return; sleep $timeout; done }    # 加入延时

FZF_ALT_C_COMMAND= eval "$(fzf --bash)"

alias '?'='yuncore_help'
yuncore_help(){   cat - <<'yuncore_help'
1. jump to project directories
cdp:        [openwrt] jump to fzf selected package   module, otherwise with name for specifying openwrt package   module:1.fzf-complete; 2.cheatsheet-complete; 3.fzf prompt
cdb:        [openwrt] jump to fzf selected build_dir module, otherwise with name for specifying openwrt build_dir module:1.fzf-complete; 2.cheatsheet-complete; 3.fzf prompt
cdrootfs:   [openwrt] jump to openwrt rootfs  directory; without argument by .svn.
cdqsdk:     [openwrt] jump to openwrt root    directory; without argument by .svn.
cdpkg:      [openwrt] jump to openwrt package directory; without argument by .svn.
cdromfs:    [sdk]     jump to padavan romfs   directory; without argument by .svn.
cduser:     [sdk]     jump to padavan user    directory; without argument by .svn.
cdroot:     [openwrt|sdk] jump to padavan/openwrt root directory; without argument.
cdproject:  [openwrt|sdk] jump to current project      directory selected by fzf prompt. 3.fzf prompt.
_cdproduct: [openwrt|sdk] jump to current product      directory selected by fzf prompt. 3.fzf prompt.
2. put package/product binary to /ftptmp
put_pkg:    [openwrt] put linked object to /ftptmp for debug; 1.fzf-complete; 2.cheatsheet-complete.
put_opkg:   [openwrt] put openwrt ipk   to /ftptmp for debug; 3.fzf prompt.
put_KF:     [sdk]         put last KF_Image to /ftptmp for upgrade; without argument by filename and birth time.
put_ubin:   [openwrt|sdk] put last *.ubin to /ftptmp   for upgrade; without argument by filename and birth time.
put_rbin:   [openwrt|sdk] put last *.rbin to /ftptmp   for upgrade; without argument by filename and birth time.
put_img:    [openwrt|sdk] put squashfs rootfs to /ftptmp for debug; without argument by filename.
put_bin:    [openwrt|sdk] put linked library and execute filename in recursive directory. by linked flag。
3. build(make) source to binary
mkuser:     [sdk] fuzzy   jump to padavan user/package directory; argument as env variable; compile and put_pkg it:    3.fzf prompt or directly package by 1.fzf-complete
mksdk:      [sdk] package jump to padavan user/package directory; argument as env variable; compile and put_pkg it:    3.fzf prompt or directly package by 1.fzf-complete
mkpkg:      [openwrt] fzf fuzzy find package, argument as command otherwise env variable; after call put_pkg for debug 3.fzf prompt
mkmod:      [openwrt] fzf fuzzy find module,  argument as command otherwise env variable;                              3.fzf prompt
makekm:     [openwrt] fzf fuzzy find module,  argument as command otherwise env variable;                              3.fzf prompt
mkqsdk:     [openwrt] jump to openwrt root directory; then eval $@(mkqsdk arguments),  need compile command
mklaste:    [openwrt] fzf fuzzy with command, argument as package;  otherwise env variable; after call put_pkg for debug 1.fzf-complete; 2.cheatsheet-complete;
mklastq:    [openwrt] 1st: package                               ; after call put_pkg for debug                          1.fzf-complete; 2.cheatsheet-complete;
mklastp:    [openwrt] 1st: package                               ; auto  call put_pkg for debug                          1.fzf-complete; 2.cheatsheet-complete;
mklast:     [openwrt] 1st: package 2st: command (default as clean,compile), otherwise env variable; ; -x: call mklaste fzf fuzzy with command
mklastv:    [openwrt] 1st: package 2st: command (default as clean,compile), otherwise env variable; ; after call put_pkg 3.fzf prompt or directly productname
mkall:      [openwrt|sdk] fzf fuzzy find product; compile product; and put last *.ubin to /ftptmp for upgrade
mkall0:     [openwrt|sdk] 'mkall zh 0'
makeromfs:  [sdk]          make romfs option in padavan module
4. add cross-tool to PATH
cross_path_arm:  [openwrt] add arm  cross compile tools to PATH
cross_path_mips: [openwrt] add mips cross compile tools to PATH
5. mklast/mklastv/mklaste/mklastq/cdb/cdp/mksdk complete by fzf
6. tlr tlnr tla tlna       auto telnet remote server by expect + tclsh
alias tlnr111='telnetwfl    root   "890h*_f0%g09y" 192.168.111.1'
alias tlna111='telnetwfl    admin  "890h*_f0%g09y" 192.168.111.1'
yuncore_help
}


alias '??'='wfl_help'
wfl_help(){   cat - <<'wfl_help'
repeat_ok/repeat_err/repeat_sleep   repeat eval "$@" command
gitc                                initialize git directory
sourcebash: source ~/.bashrc        update bash                                 enhanced by ctrl-b+b
sourcetmux: source ~/.tmux.conf     update tmux
psmem10: sort mem top 10            top
pscpu10: sort cpu top 10            top
makee/makew: trace error/warning for making padavan                             enhanced by tmuxpaste
makes/makev: make quit or verbose for making openwrt                            enhanced by tmuxpaste
makek/makekv/makeclean: make quit or verbose for making openwrt or clean kernel enhanced by tmuxpaste
makekm: make linux kernel module;                                               enhanced by tmuxpaste
fda/fdr/fdf/fdf0/fdf1/fdf2:cdf fd   jump to parent or child directory; jump to directory enhanced by fzf
frg/frgg/frggg/fgr/(rgg | rgx):     search word 1st by rg; next by fzf
ctrl-r/ctrl-x;ctrl-r/ctrl-x;ctrl-p  command from history; command from network or note by fzf
ctlr-t/ctrl-x;ctrl-g/ctrl-x;ctrl-t/ctrl-g: dir from current; fzf-marks; cdm; fzf-bookmarks
look(dict) woman|nam|cht.sh|cheat   command snippet @ctrl-d @ctrl-m and frg @ctrl-f viminfo @ctrl-v
ugit|git-fzf-add|git-fzf-switch|git-fzf-commit: Undo git commands with ease. fzf add,switch,commit [gitui] for git preview
sysz | fuzzy-sys:                   view/edit status/config; start/stop/restart/edit process
pm;                                 Package manager wrapper (supports: pacman, paru, yay, apt, dnf, zypper, apk, brew, scoop)
viminfo/vimdir/vimchanged/vimgrep   vim history; jump to vim history; git changed filed and vimgrep by fzf with vim
filef/gitf/svn_diff/git_diff/V      edit filename; git commit(delta); git file(delta) enhanced by fzf and svn diff git diff or V pipe stream
cdm: manage(edit,append,jump)       ~/.fzf-marks and  ~/.config/fzf-bookmarks/bookmarks and ~/.cdm by fzf
tmuxpaste; tmuxalldo/tmuxsecdo/tmuxwindo; tmuxnvdo/tmuxnhdo/tmuxn4do and repl enhanced tmux by script
ctrl-p or \\<tab>                   complete by tv(file or directory) and fzf(glob); CTRL-t for complete
mkb(goln) mkg(goto)                 complete enhanced by fzf to jumping -- vs -- mkd(append) mkc(clean) mkj(jump) by bash directory stack
fzf-bookmarks -a   name [file/dir]  ctrl-g         jump to bookmark enhanced by fzf
mark              <mark>            ctrl-x;ctrl-g  jump to bookmark enhanced by fzf
https://github.com/hamvocke/lnks    https://github.com/johngrib/fav-dir  bookmark(to add)
---- 1.fzf-complete; 2.cheatsheet-complete; 3.fzf prompt 4. tv-complete(by fzf for channel) ---- pv sponge, ts, parallel
#### fzf tv up(pipr) testfinder #### screen tmux Zellij; bash zsh fish; vim vidir; sshs; choose(cut) direnv sd(sed); grex; xclip fq(jq for binary formats)
fzf     --> Flow.Launcher(win) Fluent-Search(win) tv(developing) sk(skim) peco fz(vim-fz/vim-sonictemplate/@mattn)
cat     --> bat tac highlight
ls      --> exa eza lsd
find    --> fd; find . -type f, fd --type f,rg --column --line-number --no-heading --color=always --smart-case for fzf
grep    --> rg, frg frgg frggg fgr grf rgg rgx ... ripgrep, ag, ack
diff    --> delta colordiff difftastic icdiff
du      --> dust dudc ncdu gdu godu
df      --> duf
tree    --> broot erdtree lstr(bgreenwell)
cd      --> fdf fdr fda fdf0, cdf fd, fzf-marks fzf-bookmarks mark; mkb(goln) mkg(goto), fav [add | rm | list | clean | help], z, fasd, autojump, zoxide
history --> fzf tv mcfly atuin
tldr    --> cheat(fzcheat) cht.sh(chtfzf.sh / chtfzf) 3.rcheat: echo ${FZF_CHEATSHEETS_DIR}/cheatsheets/* | sed 's/ /\n/g' | fzf; tealdeer
man     --> woman nam pet 1.cht.sh(cheatsheet)|rcheat 2.https://www.mankier.com/ (manual) 3. explain 'ls -l' (cmd option) 4. tldr --> tealdeer
wgetcurl--> httpie, curlie, xh
jq      --> jp fx gron(grep), jsonfilter(openwrt), jqifzf, jqfzf csvtk(CSV/TSV格式) dsq(JSON、CSV、Excel 等格式的文件执行 SQL 查询语句) yq(yaml,json,xml) xmllint xpath gron jd htmlq
ping    --> gping fping mtr tcping # json https://jmespath.org/
dig     --> dog doggo
ranger  --> fzf vifm vipe vidir broot nnn
hexdump --> hexyl xxd od vim hexabyte
git     --> gitui lazygit tig gh --> switch restore sparse-checkout worktree bisect
tcpdump --> bandwhich sar -n DEV; sar -n EDEV
inotifywait --> reflex entr watchexec await
top     --> btop, bottom, glances, gtop, zenith, dool
glow    --> presenterm mdcat mdp
bandwhich --> sar -n DEV
dufs    --> miniserve; python3 -m http.server 8080; python -m SimpleHTTPServer 8080; --> socat, socat, netcat
tabview https://github.com/shshemi/tabiew --> https://tableconvert.com/
hyperfine  https://www.linuxlinks.com/ https://alternativeto.net/
wfl_help
}




alias '?v'='wfl_vim_help'
wfl_vim_help(){   cat - <<'wfl_vim_help'
🔋 --- vim命令行 -- 🛠️ \f!:AsyncRun  \!:Shell  \f`: H  \`: Ex 快捷键 ("ayy@a : 把当前行作为一个Vim命令来执行) -search-> :set ignorecase                   🔋 :h i_CTRL-R
<C-R> <C-W>  : pull word under the cursor into a command line or search # 🔄 Ag Rg Lines BLines Tags BTags vimgrep vimgrepadd grep grepadd lvimgrep lgrep /<C-R><C-W> ?<C-R><C-W>
<C-R> <C-A>  : pull whole word including punctuation                    # 🔄 Ag Rg Lines BLines Tags BTags vimgrep vimgrepadd grep grepadd lvimgrep lgrep /<C-R><C-A> ?<C-R><C-A>
<C-R> <C-L>  : pull the whole line under the cursor             行发送  # 🛠️ 🔴 H(发送给term-help) AsyncRun(异步后台) Shell(同步前台) Ex(ex命令) FloatermSend(发送给term) --name=ft1
<C-R> <C-F>  : pull the file name under the cursor  %:p:h文件所在文件夹 # 🛠️ 🌸 FZF Files FZFFiles; f1:FZFFiles! ~/.vim/snippet; f2:FZFFiles! ~/.vim/registers # <C-R> <C-P>
<C-R> -      : pull small register                            范围发送  # 🛠️ 🔴 :'<,'>FloatermSend  :'<,'>AsyncRun  :'<,'>TP! run runa snippet :'<,'>!cat -n
<C-R> [a-z]  : pull named registers                                     # 🛠️ 寄存器内容
<C-R> %      : pull file name (also #)                                  # 🛠️ 🔴 \f!:AsyncRun  \!:Shell  \f`: H  \`: Ex 快捷键
🔋 --- vim 插入补全 -- 🛠️  \fs snippet补全; \fS vim-sonictemplate; f1:访问snippet f9:生成snippet f2:与rv共享文件 cat file | rv <a-z>; or rv <a-z> + <C-D> 🔋 :h i_CTRL-R
<C-N>        : 普通关键字        :h 'complete'                | complete=.,w,b,u,t,i;  :set complete-=i; :set complete+=k
<C-X><C-N>   : 当前缓冲区关键字  :h compl-current             | <C-N> : 使用来自补全列表的下一个匹配项(next 匹配项)
<C-X><C-I>   : 当前文件和包含文件中的关键字 :h compl-keyword  | <C-P> : 使用来自补全列表的上一个匹配项(previous 匹配项)
<C-X><C-]>   : 标签     :h compl-dictionary :h compl-tag      | <Down>: 选择来自补全列表的下一个匹配项
<C-X><C-K>   : 单词补全: set ignorecase 和 set infercase      | <Up>  : 选择来自补全列表的上一个匹配项
<C-X><C-L>   : 文件行补全:当前编辑会话内所有缓冲区的内容      | <C-Y> : 确认使用当前选中的匹配项(yes)
<C-X><C-F>   : 文件名补全                                     | <C-E> : 还原最早输入的文本(从自动补全中exit)
<C-X><C-O>   : 全能(Omni)补全   :h compl-omni                 | <C-H> : (与 <BS>) 从当前匹配项中删除一个字符
<C-X><C-V>   : Vim 命令                                       | <C-L> : 从当前匹配项中增加一个字符
🔋 --- vim mark跳转 -- \fm   小写位置标记只在每个缓冲区局部可见,大写位置标记则全局可见: :delmarks a-z; :marks -search-> :set complete; :delmarks! " delete all lowercase marks
`<       : 上次高亮选区的起始位置 # 基于mark的复制 "ay`a   "ad`a  "ac`a  # yiw viwp 或 viw"0p 或 ciw Ctrl-R 0 Esc (.) repeat @replace word with last-yanked text
`>       : 上次高亮选区的结束位置 # 基于mark的复制 "ay`a   "ad`a  "ac`a  # yiw viwp 或 viw"0p 或 ciw Ctrl-R 0 Esc (.) repeat @replace word with last-yanked text
gi       : Move to the last insertion you did and switch to INSERT mode. # 最后修改 1. g, : 跳转至修改历史中较晚修改的位置  2. g; : 跳转至修改历史中较早修改的位置 
'.       : jump to               last modification line (SUPER)          # 最后修改         # <C-w> w 切换窗口
`.       : jump to exact spot in last modification line                  # 最后修改         # <C-w> x 用下一个交换当前
''       : jump back (to line     in current buffer where jumped from)   # 最后跳转         # <C-w> h 转到左/右窗口
``       : jump back (to position in current buffer where jumped from)   # 最后跳转         #
`"       : jump to position where last exited current buffer             # 最后编辑文件     # /foo\c  向后搜索(不区分大小写) \v very magic   \m magic
`0       : jump to position in    last file edited (when exited Vim)     # 最后编辑文件     # /foo\C  向后搜索(  区分大小写) \V very nomagic \M nomagic
]'       : jump to next line with a lowercase mark     (previous mark)   # 下一个mark       # do / :diffget 获取(get)差异
['       : jump to previous line with a lowercase mark   (next mark)     # 上一个mark       # dp / :diffput 放差价
`[ or `] : jump to beginning/end of previously changed or yanked text    # [( [{ [<  : Previous ( or { or <  🔄  ])  Next
🌸 --- number -- zed 使用fzf快速访问 z:shortcut; e: asynctask d: userdefined # fzf 快捷键
🛠️ f0(tslime) f1:(访问snippet) f2:(与rv共享文件) f3:邻居文件 f4:工程文件 f5:文件编译              f6:文件运行                      f7:选择运行     f8:供参运行      f9:(生成snippet)
🛠️ F1(帮助)   F2:number        F3:list           F4:relativenumber       F5:文件编译 \F5:文件运行 F6:净化代码 \F6:依据类型净化代码 F7:静态代码检测 F8:max/min window
🛠️ F10: FloatermToggle F9:FloatermNext \F9:FloatermPrev  F11:工程级别tags \F11:sh文件tags  F12和\F12: 功能级别cscope
🛠️ \F1(quickfix) \F2 Taglist  \F3 邻居文件列表   \F3 VimRegEdit
--- vim dir -- 🛠️ 1. <leader>f> # 跳转进入 2. <leader>cd # 进入当前文件所在目录 3. <leader>cc # 回到上个目录
--- misc    -- 🌈 vim哲学    🌈: [主]谓[宾] ["a]y[aw] [主语存在默认主语];[谓语是必须的;] 宾语也存在默认宾语
1. 100i# 插入100个连续的#号 1.1 5o<Esc> 插入5个空行; 1.2 5O<Esc> 1.3 o<Esc>4.                   🌈: 1. guu:行小写; 2. gUU:行大写 3. g~~:行翻转 4. gUw:字小写
2. sed -i '/pattern/s/old/new/g' --> g/pattern/s/old/new/g --> g/FfL /normal gcc(注释)|d(删除)  🌈: 5. g~w:字翻转  6. vU:大写字母; vu:小写字符 V~:大小写字符
3. :vimgrep /pattern/ **/*.py      " 仅搜索python文件 3.1 \f? 多行搜索             4.2 :s#/path/to/old#/path/to/new#g  " using # as delimiter
4. :[range]global/{pattern}/[cmd]对指定范围内匹配{pattern}的所有行执行Ex 命令{cmd} 4.1 :s|/usr/bin|/usr/local/bin|g    " using | as delimiter  --> d/y/c </>/= g~/gu/gU/!
:[range]delete [x] : 删除指定范围内的行[到寄存器x中] | :[range]copy   {address} : 把指定范围内的行拷贝到 {address} 指定的行之下 | :g/foo/t$  : 将包含 foo 的行复制到 EOF
:[range]yank   [x] : 复制指定范围的行[到寄存器x中]   | :[range]move   {address} : 把指定范围内的行移动到 {address} 指定的行之下 |:g/foo/m$   : 将包含 foo 的行移动到 EOF
:[line]put     [x] : 在指定行后粘贴寄存器x中的内容   | :[range]normal {commands}对指定范围内的每一行执行普通模式命令 {commands} | :%norm jdd : 隔行删除
4.1 (:5,10m 20) move lines 5-10 to after line 20;    | (:1,5co 10) copy lines 1-5 to after line 10          | (:5,10t'b) copy lines 5-10 to mark 'b'
(:pu   ): paste register contents below current line | (:pu!  ): paste register contents above current line | (:5a     )     append after  line 5
(:pu a ): paste register 'a' below current line      | (:pu! a): paste register 'a' above current line      | (:5i     )     insert before line 5
(:1,3y a): yank lines 1-3 to register 'a'            | (:5,10normal A;) append semicolon to lines 5-10      | (:%normal I//) comment all lines with //
5. <C-\><C-n> 和 <C-\><C-G> 回到normal模式           | <C-\><C-G> 临时 回到normal模式                       | ( Ctrl+r !date)  insert output of date command
wfl_vim_help
}

alias '?t'='wfl_tmux_help'
wfl_tmux_help(){   cat - <<'wfl_tmux_help'
#### 1. 可自定义快捷键 # F10:window 10 F1~F9:window 11~19                             # 更快更好更高效 f:key-bindings                     @增强记忆自定义快捷键
# t:last-pane o|"/%   |  0:last-window p|n  | L:last-session (|)                      | 最近跳回                                          @更快的跳转
# g:switch pane       |  c-g:switch window  | G:switch session                        | fzf选择跳转                                       @更好的跳转
# x:kill-pane         |  c-x(&):kill window | X:kill session                          | 杀死对象                                          @更好的杀死
# e:session cmd       |  c-e:window cmd     | E:all session cmd                       | 并发执行命令/脚本                                 @更好的并发
# c-z: suspend-client |  z: resize-pane -Z  | t: tmux last-pane; tmux resize-pane -Z  | 退出client/pane                                   @更好的切换
# b: all session source /home/wangfuli/.bashrc      vs r: source-file ~/.tmux.conf    | 加载.bashrc和.tmux.conf配置                       @更好的调试 .tmux.conf
#### 2. 可融合fzf交互提示 f(fzf) w(choose-tree) : choose-buffer choose-client         # 模糊记忆模糊搜索
# f:  tmux fzf launch key                                                             | 处理ses/win/pane/clipboard等对象                  @更好的对象
# find ~/.tmuxp/* -type f | fzf | xargs tmuxp load -y # tmuxp可帮助您管理tmux工作区   | 配置定义工作区                                    @更好的环境
#### 3. tmux脚本和函数 #### xpane(https://github.com/greymd/tmux-xpanes) 和 tmuxp:https://github.com/tmux-python/tmuxp                    @更好的并发执行命令
# tmuxalldo/tmuxsesdo/tmuxwindo 在多窗口并发执行特定命令;                             | 并发执行命令/脚本                                 @更好的构建环境
# tmuxnhdo/tmuxnvdo/tmux4ndo    在新session中创建2 horizontal/vertical和4分窗口; repl根据文件名创建 vim tslime(repl)环境 | 快速定义工作区 @更好的调试bash/python/perl/javascript
# tmuxpaste                     当前paste中内容重定向到vim                            | 使用vim编辑pane的历史记录                         @更好的buffer管理
# tmuxnotice                    产品编译之后通知编译完成                              | 使用tmuxalldo通知终端用户                         @更好的完成通知
#### 4. 融合vim tslime调试脚本                                                        | tslime # 更好的调试bash/python/perl/javascript    @与vim集成调试
#### 5. https://tmuxp.git-pull.com/about_tmux.html <<tao-of-tmux.pdf>>                | tmuxp  # 自定义的构建环境                         @与bash集成开发环境
# tmux+fzf                                                 (通过fzf提示避免快捷键记忆)|
# tmux+vim                                                 (交互式方式进行脚本调试)
# tmux+save|restore                                        (将工作环境进行保存和恢复)
# tmux跳转(panes:T/z(或者/)(<-|->和{}) windows:0(n/p) sessions:L()) (快速切换pane/window/session)
# 当前session并发:   e 所有session并发:     E  当前windows并发:    ctrl-e  (并发在session中执行命令)
# 所有pane之间跳转:  g 所有session之间跳转: G  所有session之间跳转:ctrl-g  (tmux跳转用于历史跳转,此处使用fzf选择跳转)
# 关闭当前pane:      x 关闭当前session:     X  关闭当前windows     ctrl-x  (x默认是pane关闭命令,其他为扩展)
# 跳转pane并最大化:  t 用pane平分windows: z或/ 左右跳转window中pane 向左 <- | -> 向右
# 复制当前clipboard到/tmp某个文件: y
wfl_tmux_help
}

mkd() {
  builtin pushd $(pwd) &> /dev/null; 
}
mkc() { 
  while builtin popd  &> /dev/null; do :; done
}
mkj() {
  local dir=$(builtin dirs -p | fzf)
  [ -d "$dir" ] && cd "$dir"
}

# eval "$(starship init bash)" # 跨shell的可定制的提示符

source ~/.fzf/shell/key-bindings.bash
source ~/.fzf/shell/completion.bash

[ -f ~/.fzf.bash ] && source ~/.fzf.bash

export FZF_MARKS_JUMP='\C-x\C-g'
[ -d /home/wangfuli/git/fzf-marks ] && source /home/wangfuli/git/fzf-marks/fzf-marks.plugin.bash
alias fzf-bookmarks='source ~/.vim/bin/fzf-bookmarks'

FZF_CHEATSHEETS_DIR="/home/wangfuli/git/fzf-cheatsheets"
export PATH="$PATH:${FZF_CHEATSHEETS_DIR}/bin"
source "${FZF_CHEATSHEETS_DIR}/shell/fzf-cheatsheets.bash"
export PATH="$PATH:/home/wangfuli/git/cheatsheets"

# rvim recored interactivel between bash; used by ctrl-xctrl-p
rcheat() {
  [ -z "$1" ] && {
    find ${FZF_CHEATSHEETS_DIR}/cheatsheets/ | fzf
    return 0
  }
  { pipe || (history | sed 's/[0-9 -:]*//' | fzf ; ) ; } >> ${FZF_CHEATSHEETS_DIR}/cheatsheets/$1
}

r0() {
  local alpha
  if [ -z "$1" ]; then
    local f=$(find  ${FZF_CHEATSHEETS_DIR}/cheatsheets -name "r[a-z0-9]" -type f | fzf)
    [ -n "$f" ] && bat $f
    return
  fi

  local append=$(tr '[A-Z]' '[a-z]'  <<< $1)
  for i in {A..Z}; do
    if [ "$i" = "$1" ]; then
      : > ${FZF_CHEATSHEETS_DIR}/cheatsheets/r${append}
      break
    fi
  done
  shift
  [ -n "$1" ] &&  echo "#### $@ ####" >> ${FZF_CHEATSHEETS_DIR}/cheatsheets/r${append}
  { pipe || (history | sed 's/[0-9 -:]*//' | fzf ; ) ; } >> ${FZF_CHEATSHEETS_DIR}/cheatsheets/r${append}
  echo >> ${FZF_CHEATSHEETS_DIR}/cheatsheets/r${append}
  echo >> ${FZF_CHEATSHEETS_DIR}/cheatsheets/r${append}
}

# ctrl-d
rv() {
  local alpha
  if [ -z "$1" ]; then
    local f=$(find  ~/.vim/registers -name "r[a-z0-9]" -type f | fzf)
    [ -n "$f" ] && bat $f
    return
  fi

  local append=$(tr '[A-Z]' '[a-z]'  <<< $1)
  for i in {A..Z}; do
    if [ "$i" = "$1" ]; then
      : > ~/.vim/registers/r${append}
      break
    fi
  done
  shift
  [ -n "$1" ] &&  echo "#### $@ ####" >> ~/.vim/registers/r${append}
  { pipe || cat - ; } >> ~/.vim/registers/r${append}
  echo >> ~/.vim/registers/r${append}
  echo >> ~/.vim/registers/r${append}
}

emoji-fzf() {
    # TODO (k): <2022-03-07> cache
    local cache_file=~/.cache/emoji-fzf-cache
    if ! [[ -s $cache_file ]]; then
        wget 'https://git.io/JXXO7' -O $cache_file
    fi
    selected_emoji=$(cat $cache_file | fzf)
    echo $selected_emoji
}

#### fzf + vim ####
# fe [FUZZY PATTERN] - Open the selected file with the default editor
#   - Bypass fuzzy finder if there's only one match (--select-1)
#   - Exit if there's no match (--exit-0)
fe() {
  IFS=$'\n' files=($(fzf-tmux --query="$1" --multi --select-1 --exit-0))
  [[ -n "$files" ]] && ${EDITOR:-vim} "${files[@]}"
}

fzfrun(){  # tmux大量日志情况下,分析日志信息
  eval "$@" 2>&1 > /tmp/fzfrun.log
  cat /tmp/fzfrun.log | fzf --bind "enter:execute(vim /tmp/fzfrun.log)"
}

alias fzfv='vim $(fzf -m --bind "ctrl-e:execute(vim {})" --bind "ctrl-o:execute(xdg-open {})" --bind "ctrl-a:select-all" --bind "ctrl-d:deselect-all" --preview "bat --style=numbers --color=always {}" )' #用来多选:TAB选中和Shift-TAB取消
alias fzfe='fzf --bind "enter:execute(vim {})" --bind "ctrl-e:execute(vim {})" --bind "ctrl-o:execute(xdg-open {})" --bind "ctrl-a:select-all" --bind "ctrl-d:deselect-all" --preview "bat --style=numbers --color=always {}"'
alias fzftmp='find /mnt/hgfs/ftptmp -maxdepth 1 -type f | fzf -m --bind "enter:execute(vim {})" --bind "ctrl-o:execute(xdg-open {})" --bind "ctrl-e:execute(vim {})" --bind "ctrl-a:select-all" --bind "ctrl-d:deselect-all" --preview "bat {}"'
alias fzfcheat='find /home/wangfuli/git/fzf-cheatsheets/cheatsheets -type f | fzf -m --bind "enter:execute(vim {})" --bind "ctrl-e:execute(vim {})" --bind "ctrl-o:execute(xdg-open {})" --bind "ctrl-a:select-all" --bind "ctrl-d:deselect-all" --preview "bat -l sh {}"'

viminfo (){
  local files;
  files=$(grep '^>' ~/.viminfo | cut -c3- |
    while read line; do
    [ -f "${line/\~/$HOME}" ] && echo "$line"
    done | fzf -d -m -q "$*" -1) && vim ${files//\~/$HOME}
}

vimdir () {
    local files;
    files=$(grep '^>' ~/.viminfo | cut -c3- |
    while read line; do
    [ -f "${line/\~/$HOME}" ] && echo "$line"
    done | fzf -d -m -q "$*" -1) && cd $(dirname $files)
}

vimchanged(){
    local git_root
    git_root="$(git rev-parse --show-toplevel)"
    # want splitting
    # shellcheck disable=SC2046
     git status --porcelain | \
     awk '/^.M/ {$1=""; print}' | \
     sed "s|^[[:space:]]|$git_root/|" | \
     fzf --print0  --bind  '?:preview: git diff --color=always {}'
}

vimhome(){
    # must expand in vim, not in shell
    # shellcheck disable=SC2016
    vim -Nesc '!echo $VIMRUNTIME' -c qa |
    #tr -dc '[:alnum:]/\r\n'
    sed 's,[^/]*/,/,'
}

# same as frg -l
vimgrep(){
    if [ $# -lt 2 ]; then
        echo "usage: vimgrep <pattern> <files>"
        return 3
    fi
    # want splitting
    # shellcheck disable=SC2046
    vim $(grep -l "$1" "$@" | sort -u | fzf)
}

pythonpath(){
    python -c 'from __future__ import print_function; import sys; [print(_) for _ in sys.path if _]'
}

open(){
    if type -P xdg-open &>/dev/null; then
        xdg-open "$@"
    elif sensible-browser &>/dev/null; then
        sensible-browser "$@"
    elif x-www-browser &>/dev/null; then
        x-www-browser "$@"
    elif gnome-open &>/dev/null; then
        gnome-open "$@"
    else
        echo "Neither 'xdg-open' nor 'sensible-browser' were found in \$PATH - install one of them to automatically open this URL:"
        echo
        echo "$*"
        echo
    fi
}

# Modified version where you can press
#   - CTRL-O to open with `open` command,
#   - CTRL-E or Enter key to open with the $EDITOR
fo() {
  IFS=$'\n' out=("$(fzf-tmux --multi  --query="$1" --exit-0 --expect=ctrl-o,ctrl-e)")
  key=$(head -n 1 <<< "$out")
  file=$(head -n 2 <<< "$out" | tail -n 1)
  if [ -n "$file" ]; then
    [ "$key" = ctrl-o ] && open "$file" || ${EDITOR:-vim} "$file"
  fi
}

#### fzf + grep + vim ####
# vf - fuzzy open with vim from anywhere
# ex: vf word1 word2 ... (even part of a file name)
# zsh autoload function
vf() {
  local files

  files=(${(f)"$(locate -Ai -0 "$@" | grep -z -vE '~$' | fzf --read0 -0 -1 -m)"})

  if [[ -n $files ]]
  then
     vim -- $files
     print -l $files[1]
  fi
}

# fuzzy grep open via ag
vg() {
  local file

  file="$(ag --nobreak --noheading "$@" | fzf -0 -1 -m | awk -F: '{print $1}')"

  if [[ -n $file ]] ; then
     vim $file
  fi
}

# fuzzy grep open via ag with line number
vgf() {
  local file
  local line

  read -r file line <<<"$(ag --nobreak --noheading "$@" | fzf -m -0 -1 | awk -F: '{print $1, $2}')"

  if [[ -n $file ]] ; then
     vim $file +$line
  fi
}

vgd() {
  local file

  file="$(ag --nobreak --noheading "$@" | fzf -0 -1 | awk -F: '{print $1}')"

  if [[ -n $file ]] ; then
     cd $(dirname $file)
     eval xsync
  fi
}

#### fzf + cd ####
# fd - cd to selected directory
# fd() {
#   local dir
#   dir=$(find ${1:-.} -path '*/\.*' -prune \
#                   -o -type d -print 2> /dev/null | fzf +m) &&
#   cd "$dir"
#   eval xsync
# }
# fda - including hidden directories
fda() {
  local dir
  dir=$(find ${1:-.} -type d 2> /dev/null | fzf +m) && cd "$dir"
  eval xsync
}
# fdr - cd to selected parent directory
fdr() {
  local declare dirs=()
  get_parent_dirs() {
    if [[ -d "${1}" ]]; then dirs+=("$1"); else return; fi
    if [[ "${1}" == '/' ]]; then
      for _dir in "${dirs[@]}"; do echo $_dir; done
    else
      get_parent_dirs $(dirname "$1")
    fi
  }
  local DIR=$(get_parent_dirs $(realpath "${1:-$PWD}") | fzf-tmux --tac)
  cd "$DIR"
  eval xsync
}

# fdf - cd into the directory of the selected file
fdf() {
  local file
  local dir
  local searchfile
  local searchdir
  local regex
  local maxdepth
  local week
  while getopts ':m:fdxwhL' x; do
      case "$x" in
          m) maxdepth=${OPTARG} ;;
          f) searchfile="1" ;;
          d) searchdir="1" ;;
          x) regex="1" ;;
          w) week="1" ;;
          L) folllow="1" ;;
          h) echo "fdf [-m|maxdepth depth] [-f|searchfile] [-d|searchdir] [-x|regex] [-w|oneweek days]"
             echo "fdf "         # find filename and dirname
             echo "fdf -f "      # find filename
             echo "fdf -d "      # find dirname
             echo "fdf -m 2"     # find maxdepth include filename and dirname
             echo "fdf -m 2 -d " # find maxdepth and only dirname
             echo "fdf -m 2 -f " # find maxdepth and only filename
             return;
      esac
  done
  shift $(( OPTIND - 1 ))
  unset x OPTARG OPTIND

  FD_PREFIX="find"
  [[ -n $regex ]] && FD_PREFIX="$FD_PREFIX -regex "
  [[ -n $searchfile ]] && FD_PREFIX="$FD_PREFIX -type f "
  [[ -n $searchdir  ]] && FD_PREFIX="$FD_PREFIX -type d "
  [[ -n $searchdir  ]] && FD_PREFIX="$FD_PREFIX -type d "
  [[ -n $maxdepth  ]] && FD_PREFIX="$FD_PREFIX -maxdepth $maxdepth "
  [[ -n $folllow  ]] && FD_PREFIX="$FD_PREFIX --follow  "
  [[ -n $week  ]] && FD_PREFIX="$FD_PREFIX --atime 7 "
  file=$( { pipe || $FD_PREFIX;} | fzf +m  -q "$1" --prompt 'Dirs+Files> ' --bind "start:show-header" --header '/ ctrl-o:open ctrl-e:vim / arguments: [-m|maxdepth depth] [-f|searchfile] [-d|searchdir] [-x|regex] [-w|oneweek days] [-L] /'  )

  [ -z "$file" ] && {
    return
  }
  [ -d "$file" ] && {
    cd "$file"
  } || {
    dir=$(dirname "$file") && cd "$dir"
  }
  eval xsync
}

# fdf0 - cd into the directory of the selected file
fdf0() {
  local file
  local dir
  file=$({ pipe || find ; }  | fzf +m -q "$1" --prompt 'All> ' --bind "start:show-header" \
             --header '🎛️ ^d: Dirs / ^f: Files / ^t : Dirs + Files / F9: maxdepth=1 / F10: maxdepth=2 / ^e (edit bookmark) ⚡️ cdm -a [-mbi] [fzf-marks|fzf-bookmarks|mybookmark] |^x^t:cdm ^g:fzf-bookmarks ^x^g:fzf-marks' \
             --bind 'del:execute(rm -ri {+})' \
             --bind 'ctrl-t:change-prompt(All> )+reload(find -L *)' \
             --bind 'ctrl-d:change-prompt(Dirs> )+reload(find * -type d)' \
             --bind 'f9:change-prompt(Dirs1> )+reload(find * -maxdepth 1 -type d)' \
             --bind 'f10:change-prompt(Dirs2> )+reload(find * -maxdepth 2 -type d)' \
             --bind 'ctrl-f:change-prompt(Files> )+reload(find * -type f)')
  [ -z "$file" ] && {
    return
  }
  [ -d "$file" ] && {
    cd "$file"
  } || {
    dir=$(dirname "$file") && cd "$dir"
  }
  eval xsync
}

# fdf1 - cd into the directory of the selected file
fdf1() {
  local file
  local dir
  local sorttime
  local sortsize
  local sortreverse
  while getopts ':tsrdh' x; do
      case "$x" in
          t) sorttime="1" ;;
          s) sortsize="1" ;;
          r) sortreverse="1" ;;
          d) jumpdir="1" ;;
          h) echo "fdf1 -t|sorttime -s|sortsize -r|sortreverse -d|jumpdir otherwise edit with vim"
             echo "fdf1 "       # sorttime older first
             echo "fdf1 -t "    # sorttime size
             echo "fdf1 -s "    # sortsize
             echo "fdf1 -t -r " # sorttime
             echo "fdf1 -s -r " # sorttime
             return;
      esac
  done
  shift $(( OPTIND - 1 ))
  unset x OPTARG OPTIND

  SORT_PREFIX="sort"
  [[ -n $sortreverse ]] && SORT_PREFIX="$SORT_PREFIX -r "
  if [[ -n $sorttime ]] ; then
    file=$(find -type f -printf '%T+ %p\n'  | $SORT_PREFIX  | awk '{print $2}' | grep -v -e ".svn" -e ".git" -e ".github" | fzf +m -q "$1" --preview 'ls -hl {} ; ls -l {} ; stat {}')
    if [[ -n $file ]]; then
      if [[ -n $jumpdir ]] ; then
        dir=$(dirname "$file") && cd $dir
      else
        vim $file
      fi
      return;
    fi
  fi

  if [[ -n $sortsize ]] ; then
    file=$(find -type f -printf "%12s\t%p\n"  | $SORT_PREFIX -k1 -n | awk '{print $2}' | grep -v -e ".svn" -e ".git" -e ".github" | fzf +m -q "$1" --preview 'ls -hl {} ; stat {}')
    if [[ -n $file ]]; then
      if [[ -n $jumpdir ]] ; then
        dir=$(dirname "$file") && cd $dir
      else
        vim $file
      fi
      return;
    fi
  fi

  file=$(find -type f -printf '%T+ %p\n' | $SORT_PREFIX  | awk '{print $2}' | grep -v -e ".svn" -e ".git" -e ".github" | fzf +m -q "$1" --preview 'ls -hl {} ; ls -l {} ; stat {}')
  if [[ -n $file ]]; then
    if [[ -n $jumpdir ]] ; then
      dir=$(dirname "$file") && cd $dir
    else
      vim $file
    fi
  fi

  eval xsync
}

# fdf - cd into the directory of the selected file
fdf2() {
  local file
  local searchfile
  local searchdir
  local linkpath
  local hiddern
  while getopts ':m:fdlHh' x; do
      case "$x" in
          m) maxdepth=${OPTARG} ;;
          f) searchfile="1" ;;
          d) searchdir="1" ;;
          l) linkpath="1" ;;
          H) hiddern="1" ;;
          h) echo "fdf2 [-m|maxdepth depth] [-f|searchfile] [-d|searchdir] [-l|linkpath] [-H|hidden]"
             echo "fdf2 "         # find filename and dirname
             echo "fdf2 -f "      # find filename
             echo "fdf2 -d "      # find dirname
             echo "fdf2 -m 2"     # find maxdepth include filename and dirname
             echo "fdf2 -m 2 -d " # find maxdepth and only dirname
             echo "fdf2 -m 2 -f " # find maxdepth and only filename
             echo "fdf2 -l "      # find filename and dirname include linkpath
             echo "fdf2 -H "      # find filename and dirname include hidden
             return;
      esac
  done
  shift $(( OPTIND - 1 ))
  unset x OPTARG OPTIND

  FD_PREFIX="fd  "
  [[ -n $searchfile ]] && FD_PREFIX="$FD_PREFIX --type file "
  [[ -n $searchdir ]] && FD_PREFIX="$FD_PREFIX --type directory "
  [[ -n $linkpath ]] && FD_PREFIX="$FD_PREFIX --follow "
  [[ -n $linkpath ]] && FD_PREFIX="$FD_PREFIX --hidden --exclude .git --exclude .svn"
  [[ -n $maxdepth  ]] && FD_PREFIX="$FD_PREFIX -maxdepth $maxdepth "

  local file
  file=$($FD_PREFIX | fzf --bind "start:show-header" --header '/ ctrl-o:open ctrl-e:vim / arguments: [-m|maxdepth depth] [-f|searchfile] [-d|searchdir] [-x|regex] [-w|oneweek days] [-l] [-H] /' +m -q "$1" )

  [ -z "$file" ] && {
    return
  }
  [ -d "$file" ] && {
    cd "$file"
  } || {
    dir=$(dirname "$file") && cd "$dir"
  }
  eval xsync
}

ftags() {
     [ -e tags ] || ctags -e -R --languages=C --langmap=C:.h.c --c-kinds=+px --extras=+r
    export PATH=${PATH}:/home/wangfuli/git/fzf-ctags/bin
    fzf-ctags
}

cscope_build(){
    find -L . -iname '*.c' -o -iname '*.cpp' -o -iname '*.h' -o -iname '*.hpp' > cscope.files &&
    sort cscope.files > cscope.files.sorted && mv cscope.files.sorted cscope.files &&
    cscope -kbq -i cscope.files -f cscope.out &&
    ctags -R --fields=+aimSl --c-kinds=+lpx --c++-kinds=+lpx --exclude='.svn' \
    --exclude='.git' --exclude='*.a' --exclude='*.js' --exclude='*.pxd' --exclude='*.pyx' --exclude='*.so' &&
    echo "Done."
}


bind -x '"\C-x\C-y":fzfy'    # fzf + ~/.local/share/yank_history   ==> yank

                             # 1. t (current directory)
bind -x '"\C-x\C-t":cdm'     # 2. (all noted directory)
bind -x '"\C-g":fzf-bookmarks' # 3. (current directory)
                             # 4. xg (fzf-marks)

                             # 1. r (bash noted command)
bind -x '"\C-x\C-r":chtfzf'  # 2 (networkd noted command)
                             # 3. xp (user noted command)

bind -x '"\C-x\C-f":frg'     # 1.xf (frg grep)
bind -x '"\C-x\C-v":viminfo' # 2.xv (current noted file)
bind -x '"\C-x\C-m":woman'   # 3.xm (current manual + chtfzf/user noted command)
bind -x '"\C-x\C-d":look'    # 4.xd (dict/words)

function pet-select() {
  BUFFER=$(pet search --query "$READLINE_LINE")
  READLINE_LINE=$BUFFER
  READLINE_POINT=${#BUFFER}
}
bind -x '"\C-x\C-n": pet-select' # 3. xn (user noted command)
function pet-prev() {
  PREV=$(echo `history | tail -n2 | head -n1` | sed 's/[0-9]* //')
  sh -c "pet new `printf %q "$PREV"`"
}

# bind -x '"\C-x\C-r": pet-select'
# bind -x '"\C-t":__fzf_cd__'    # fzf + ubuntu
# bind -m emacs-standard '"\C-e": " \C-b\C-k \C-u`__fzf_select__`\e\C-e\er\C-m\C-y\C-h\e \C-y\ey\C-x\C-x\C-d"'

# CTRL-X-1 - Invoke Readline functions by name
__fzf_readline ()
{
    builtin eval "
        builtin bind ' \
            \"\C-x3\": $(
                builtin bind -X | command fzf +s +m --toggle-sort=ctrl-r
            ) \
        '
    "
}
alias '???'=__fzf_readline

builtin bind -x '"\C-x2": __fzf_readline';
builtin bind '"\C-x1": "\C-x2\C-x3"'

# export FZF_DEFAULT_COMMAND='fd'
export FZF_COMPLETION_TRIGGER='\'
# export FZF_TMUX=1
export FZF_TMUX_HEIGHT='80%'
# export fzf_preview_cmd='[[ $(file --mime {}) =~ binary ]] && echo {} is a binary file || (bat --color=always || ccat --color=always {} || highlight -O ansi -l {} || cat {}) 2> /dev/null | head -500'


# bat
[[ -x $(command -v bat) ]] && { alias cat="bat"; alias more="bat";  export MANPAGER="sh -c 'col -bx | bat -p -l man'"; }

# V some command output; like git diff;svn diff; ls;
V() { { pipe || "$@" ; } 2> /dev/null | view - ; } # Quick way to view files in vim

# find fd ag for filename, end preivew or edit it
filef() { { pipe || "$@" ; } 2> /dev/null | awk '{print $NF}' | fzf ; }    # Quick way to view files in fzf preview

# grep rg with line number
# grep rg with line number
alias rgg="rg --column --line-number --no-heading --crlf --color=always "
rgx ()  {
  [ -n "$SSH_CLIENT" ] && {
      open=less
  } || {
      open=xdg-open
  }

  if [ "$(uname -o)" = "Cygwin" ]; then
    open() {
      for f in $@; do
        cygstart "$(cygpath -w $f)"
      done
    }
  fi

{ pipe || rg --column --line-number --no-heading --crlf --color=always "$1" ; } | fzf --ansi \
    --prompt '1. fzf> ' \
    --delimiter : \
    --header '/ CTRL-F (fzf mode) ╱' \
    --preview='bat -n --color=always --style=numbers,changes,header --highlight-line {2} {1}' \
    --preview-window 'right,50%,+{2}+1/3,~1' \
    --bind 'enter:become(less {1})' \
    --bind "ctrl-o:execute($open {1})" \
    --bind "ctrl-e:execute(vim {1} +{2})"
}

#### input revsion -> preview difference; end view it ####
# git log --oneline
# git reflog
# git stash list
# git tag
gitf(){
  revsion=$({ pipe || "$@" ; } 2> /dev/null | fzf --ansi  --preview "echo {} | cut -d' ' -f1 | xargs -I{} git show --color --pretty=format:%b {}")
  [ -z "$revsion" ] && return
  revsion=$(echo $revsion | awk '{print $1}')
  [ -z "$revsion" ] && return
  git show $revsion | view -
  echo "$revsion"
}

#### input [filename], end view it  ####
svn_diff(){ svn diff "$@"    | view -; }
git_diff(){ git diff -w "$@" | view -; }
#### input [filename] -> preview difference ####
# git ls-files --deleted  # deleted files
# git ls-files --modified # modified and deleted files
# git status --short .    # current directory
# git status --short      # root directory
gitd(){
{ pipe || "$@" ; } | fzf -m --print0 --preview "git diff -- {-1} | delta"
}

#### input [filename] -> preview difference; end view it ####
gitview(){
  revsion=$( { pipe || git log --oneline "$@" ; } | fzf --ansi  --preview "echo {} | cut -d' ' -f1 | xargs -I{} git show --color --pretty=format:%b {}")
  [ -z "$revsion" ] && return
  revsion=$(echo $revsion | awk '{print $1}')
  [ -z "$revsion" ] && return
  git show $revsion | view -
  echo "$revsion"
}

#  ~/.fzf-marks
#  ~/.config/fzf-bookmarks/bookmarks
cdf(){
  local file
  file=$( { pipe || "$@" ; } | fzf --ansi)

  [ -z "$file" ] && {
    return
  }
  file=$(echo $file | awk '{print $NF}')
  [ -d "$file" ] && {
    cd "$file"
  } || {
    dir=$(dirname "$file") && cd "$dir"
  }
  eval xsync
}

#  ~/.fzf-marks
#  ~/.config/fzf-bookmarks/bookmarks
cdm(){
  local cdm_marks cdm_bookmarks cdm_cdmmarks cdm_add_bookmark cdm_edit_bookmark
  while getopts 'mbiaeh' x; do
      case "$x" in
        m) cdm_marks=1 ;;
        b) cdm_bookmarks=1 ;;
        i) cdm_cdmmarks=1 ;;
        a) cdm_add_bookmark=1 ;;
        e) cdm_edit_bookmark=1 ;;
        h) echo "cdm [-m|fzf-marks] [-b|fzf-bookmarks] [-i|fzf-cdmmarks] | [-a|append] [-e|edit]"
           echo "1. -m/-b/-i jump; 2. [-m/-b/-i]+ -a append; 3. -e edit"
           echo "cdm -m [-a] " # find directory in fzf-marks    ; -a add to ~/.fzf-marks
           echo "cdm -b [-a] " # find directory in fzf-bookmarks; -a add to ~/.config/fzf-bookmarks/bookmarks
           echo "cdm -i [-a] " # find directory in fzf-cdmmarks ; -a add to ~/.cdm
           echo "cdm -e      " # edit ~/.config/fzf-bookmarks/bookmarks ~/.fzf-marks ~/.cdm
           return 0
      esac
  done
  shift $(( OPTIND - 1 ))
  unset x OPTARG OPTIND

  [ "$cdm_edit_bookmark" = "1" ] && {
    vim ~/.config/fzf-bookmarks/bookmarks ~/.fzf-marks ~/.cdm
    return 0
  }

  [ "$cdm_add_bookmark" = "1" ] && {
    [ "$cdm_marks" = "1" ] && {
      mark "$@" "$(pwd)"
    }
    [ "$cdm_bookmarks" = "1" ] && {
      fzf-bookmarks -a "$@" "$(pwd)"
    }
    [ "$cdm_cdmmarks" = "1" ] && {
      echo -e "$@ \t $(pwd)" >> ~/.cdm
    }
    return 0
  }
  [ "$cdm_marks" = "1" ] && {
    cdf cat ~/.fzf-marks
    return 0
  }
  [ "$cdm_bookmarks" = "1" ] && {
    cdf cat ~/.config/fzf-bookmarks/bookmarks
    return 0
  }
  [ "$cdm_cdmmarks" = "1" ] && {
   cdf cat ~/.cdm
    return 0
  }
  cat ~/.cdm | awk '{ print "cdm          \t " $0 }' > /tmp/cdfm.tmp
  cat ~/.config/fzf-bookmarks/bookmarks | awk '{ print "fzf-bookmarks\t " $0 }' >> /tmp/cdfm.tmp
  cat ~/.fzf-marks | awk '{ print "fzf-marks    \t " $0 }' >> /tmp/cdfm.tmp
  cdf cat /tmp/cdfm.tmp
  return 0
}

cdfm(){
  touch ~/.cdm
  [ -n $1 ] && {
    [ "$1" = "1" ] && {
      [ -f ~/.fzf-marks ] && { cdf cat ~/.fzf-marks; return; }
    }
    [ "$1" = "2" ] && {
      [ -f ~/.config/fzf-bookmarks/bookmarks ] && { cdf cat ~/.config/fzf-bookmarks/bookmarks; return; }
    }
    [ "$1" = "a" ] && {
      cdf cat ~/.cdm ~/.fzf-marks ~/.config/fzf-bookmarks/bookmarks
    }
  } || {
    cdf cat ~/.cdm
  }
}

cdmf(){
  touch ~/.cdm
  [ -n $1 ] && {
    [ "$1" = "1" ] && {
      [ -f ~/.fzf-marks ] && { cdf cat ~/.fzf-marks; return; }
    }
    [ "$1" = "2" ] && {
      [ -f ~/.config/fzf-bookmarks/bookmarks ] && { cdf cat ~/.config/fzf-bookmarks/bookmarks; return; }
    }
    [ "$1" = "a" ] && {
      cdf cat ~/.cdm  ~/.fzf-marks ~/.config/fzf-bookmarks/bookmarks
    }
  } || {
    cdf cat ~/.cdm
  }
}

# Usage:
# f cd (hit enter, choose path)
# f cat (hit enter, choose files)
# f vim (hit enter, choose files)
# f vlc (hit enter, choose files)
fzff() {
    # Store the arguments from fzf
    IFS=$'\n' arguments=($(fzf --query="$2" --multi))

    # If no arguments passed (e.g. if Esc pressed), return to terminal
    if [ -z "${arguments}" ]; then
        return 1
    fi

    # We want the command to show up in our bash history, so write the shell's
    # active history to ~/.bash_history. Then we'll also add the command from
    # fzf, then we'll load it all back into the shell's active history
    history -w

    # RUN THE COMMANDS ########################################################
    # The cd command has no effect when run as background, and doesn't show up
    # as a job the can be brought to the foreground. So we make sure not to add
    # a '&' (more programs can be added separated by a '|')
    if ! [[ $1 =~ ^(cd)$ ]]; then
        $1 "${arguments[@]}" &

    else
        # $1 "${arguments[@]}"
          arguments[0]=$(echo ${arguments[0]} | awk '{print $NF}')
          [ -d "${arguments[0]}" ] && {
            cd "${arguments[0]}"
          } || {
            dir=$(dirname "${arguments[0]}") && cd "$dir"
          }
          return 0
    fi

    # If the program is not on the list of GUIs (e.g. vim, cat, etc.) bring it
    # to foreground so we can see the output. Also put cd on this list
    # otherwise there will be errors)
    if ! [[ $1 =~ ^(cd|zathura|vlc|eog|kolourpaint)$ ]]; then
        fg %%
    fi

    # ADD A REPEATABLE COMMAND TO THE BASH HISTORY ############################
    # Store the arguments in a temporary file for sanitising before being
    # entered into bash history
    : >/tmp/fzf_tmp
    for file in ${arguments[@]}; do
        echo $file >>/tmp/fzf_tmp
    done

    # Put all input arguments on one line and sanitise the command such that
    # spaces and parentheses are properly escaped. More sanitisation
    # substitutions can be added if needed
    sed -i 's/\n//g; s/ /\\ /g; s/(/\\(/; s/)/\\)/' /tmp/fzf_tmp

    # If the program is on the GUI list add a '&' to the command history
    if [[ $1 =~ ^(zathura|vlc|eog|kolourpaint)$ ]]; then
        sed -i '${s/$/ \&/}' /tmp/fzf_tmp
    fi

    # Grab the sanitised arguments
    arguments=$(cat /tmp/fzf_tmp)

    # Add the command with the sanitised arguments to our .bash_history
    echo ${1} ${arguments} >>~/.bash_history

    # Reload the ~/.bash_history into the shell's active history
    # history -r

    # Clean up temporary variables
    echo >/tmp/fzf_tmp
}

[[ -x $(command -v bat) ]] && [[ -x $(command -v fzf) ]] && alias preview="fzf --preview 'bat --color \"always\" {}'"

#### fzf + preview ####
fzfp() {
fzf --preview '[[ $(file --mime {}) =~ binary ]] && echo {} is a binary file || (bat --style=numbers --color=always{} || rougify {}  || highlight -O ansi -l {} || coderay {} || cat {}) 2> /dev/null | head -500'
}
alias tt='fzf --preview '"'"'[[ $(file --mime {}) =~ binary ]] && echo {} is a binary file || (bat --style=numbers --color=always{} || rougify {}  || highlight -O ansi -l {} || coderay {} || cat {}) 2> /dev/null | head -500'"'"

fzfk() {
  cat /usr/share/dict/words | fzf -e  --query "$@ "
}
alias fzfy='ag -g "" -f ~/.local/share/yank_history | fzf -m --bind "enter:execute(vim {})" --bind "ctrl-e:execute(vim {})" --bind "ctrl-a:select-all" --preview "bat --style=numbers --color=always {} " '

alias tmp='find -L /ftptmp -maxdepth 1 -name "*tmp*" -o -name "*diff*" | fzf '


#### fzf + tmux ####
# tmuxs [FUZZY PATTERN] - Select selected tmux session
#   - Bypass fuzzy finder if there's only one match (--select-1)
#   - Exit if there's no match (--exit-0)
tmuxs() {
  local session
  session=$(tmux list-sessions -F "#{session_name}" | \
    fzf --query="$1" --select-1 --exit-0) &&
  tmux switch-client -t "$session"
}

# tmuxw [FUZZY PATTERN] - Select selected tmux windows in self-session
tmuxw() {
  local index name
  read -r index name <<< $(tmux list-windows -F "#{window_index} #{window_name}" | \
    fzf --query="$1" --select-1 --exit-0)
  [ -n "$index" ] && tmux select-window -t ":=$index"
}

# tmuxw [FUZZY PATTERN] - Select selected tmux windows in all-session
tmuxx() {
local session index name

read -r ses1 ses2 ses3 <<< $(tmux ls -F "#{session_name}")

read -r session index name <<< $( (
tmux list-windows -F "#{session_name} #{window_index} #{window_name}" -t $ses1;
tmux list-windows -F "#{session_name} #{window_index} #{window_name}" -t $ses2;
tmux list-windows -F "#{session_name} #{window_index} #{window_name}" -t $ses2;
) | fzf --query="$1" --select-1 --exit-0 )

[ -n "$session" ] && [ -n "$index" ] && tmux switch-client -t "$session" && tmux select-window -t ":=$index"
}

# tmuxp - switch pane (@george-b)  # bind-key 0 run "tmux split-window -p 40 'bash -ci ftpane'"
tmuxp() {
  local panes current_window current_pane target target_window target_pane
  panes=$(tmux list-panes -s -F '#I:#P - #{pane_current_path} #{pane_current_command}')
  current_pane=$(tmux display-message -p '#I:#P')
  current_window=$(tmux display-message -p '#I')

  target=$(echo "$panes" | grep -v "$current_pane" | fzf +m --reverse) || return

  target_window=$(echo $target | awk 'BEGIN{FS=":|-"} {print$1}')
  target_pane=$(echo $target | awk 'BEGIN{FS=":|-"} {print$2}' | cut -c 1)

  if [[ $current_window -eq $target_window ]]; then
    tmux select-pane -t ${target_window}.${target_pane}
  else
    tmux select-pane -t ${target_window}.${target_pane} &&
    tmux select-window -t $target_window
  fi
}

tmuxnotice(){
  command="$1"
  shift
  message="$1"
  [ -z "$message" ] && message="command"
  eval "$command"
  tmuxsesdo "echo  ⚡️⚡️⚡️⚡️ ${message} ⚡️⚡️⚡️⚡️"
}


#### fzf + history ####
# fh - repeat history
fh() {
  print -z $( ([ -n "$ZSH_NAME" ] && fc -l 1 || history) | fzf +s --tac | sed -E 's/ *[0-9]*\*? *//' | sed -E 's/\\/\\\\/g')
}

#### fzf + ps + kill ####
# fkill - kill process
fkill() {
  local pid
  pid=$(ps -ef | sed 1d | fzf -m | awk '{print $2}')

  if [ "x$pid" != "x" ] ; then
    echo $pid | xargs kill -${1:-9}
  fi
}
# fkill - kill processes - list only the ones you can kill. Modified the earlier script.
fkill() {
    local pid
    if [ "$UID" != "0" ]; then
        pid=$(ps -f -u $UID | sed 1d | fzf -m | awk '{print $2}')
    else
        pid=$(ps -ef | sed 1d | fzf -m | awk '{print $2}')
    fi

    if [ "x$pid" != "x" ] ; then
        echo $pid | xargs kill -${1:-9}
    fi
}


fman() {
    man -k . | fzf -q "$1" --prompt='man> '  --preview $'echo {} | tr -d \'()\' | awk \'{printf "%s ", $2} {print $1}\' | xargs -r man' | tr -d '()' | awk '{printf "%s ", $2} {print $1}' | xargs -r man
}

alias tmp='find -L /ftptmp -maxdepth 1 -name "*tmp*" -o -name "*diff*" | fzf '

inorun() (
  # Run command whenever a given file or a file
  # in the given directory changes.
  # inorun <file> <cmd>...
  file="$1"
  shift
  cmd="$@"
  # Run the command once when we start.
  eval "$cmd"
  while true; do \
    eval "$cmd"
    inotifywait -qre close_write "$file"
  done
)

runn() {
  n="$1"
  shift
  i=0
  while [ "$i" -lt "$n" ]; do
      if ! $*; then
        echo "FAIL i = $i"
        break
      fi
      i="$(($i + 1))"
  done
}

testprogs() (
  for f in "$@"; do
    "./$f" &>/dev/null
    if [ "$?" != 0 ]; then
      echo "$f"
    fi
  done
)
which drop      >/dev/null 2>&1 && alias f=drop
which floaterm  >/dev/null 2>&1 && alias f=floaterm
alias task='asynctask -f'

# z() {
#   [ $# -gt 0 ] && fasd_cd -d "$*" && return 0
#   local dir
#   dir="$(fasd -Rdl "$1" | fzf -1 -0 --no-sort +m)" && cd "${dir}" || return 1
# }

# --reverse --walker=dir,follow,hidden --scheme=path
#
export FZF_CTRL_T_OPTS=" \
  --border='rounded' \
  --border-label-pos=50 \
  --border-label='Find Files' \
  --preview-label='Find Files' \
  --bind 'ctrl-e:execute(vim ~/.config/fzf-bookmarks/bookmarks ~/.fzf-marks ~/.cdm)' \
  --header '🎛️ ENTER (paste selected files and dirs onto command-line)|^e (edit bookmark) ⚡️ cdm -a [-mbi] [fzf-marks|fzf-bookmarks|mybookmark] |^x^t:cdm ^g:fzf-bookmarks ^x^g:fzf-marks'"

export FZF_CTRL_R_OPTS=" \
  --border='rounded' \
  --border-label-pos=50 \
  --border-label='Command History' \
  --preview-label='Command History' \
  --bind "start:show-header" \
  --bind 'ctrl-s:execute(pet new --tag {2..})+abort' \
  --bind 'ctrl-e:execute(vim ~/.config/pet/snippet.toml)' \
  --header '🎛️ ^y (copy command into clipboard)|^s (pet new)|^e (edit pet toml) ⚡️ ^x^r:cht.sh ^x^p:fzf-cheatsheets ^x^n:pets' \
  --bind=ctrl-r:toggle-sort "

export FZF_ALT_C_OPTS=" \
  --border='rounded' \
  --border-label-pos=50 \
  --border-label='Find Dirs' \
  --preview-label='Find Dirs' \
  --header '🎛️ ENTER (cd into the selected dir)'"

# fzf-header="(ctrl-\\: jump) (ctrl-/: toggle-preview) (f1: toggle-help)  (f2: toggle-preview)
# (ctrl-a:select-all) (ctrl-d:deselect-all) (ctrl-t:select-to-top) (ctrl-b:select-to-bottom)
# (tab:select-down) (stab:select-up) (ctrl-n:next-selected) (ctrl-p:prev-selected)
# (ctrl-d:half-page-down) (ctrl-u:half-page-up) (gpup:page-up) (pgdown:page-down) (up:up) (down:down)
# (alt-up:page-up) (alt-down:page-down) (shift-up:up) (shift-down:down)
# "

# defaultHeader="f1 → default, f2 → editor, f3 → clipboard, f4 → terminal, alt+shift+d → delete"
# unset FZF_DEFAULT_COMMAND  Linux: --bind="ctrl-o:execute:xdg-open {}"  --bind="ctrl-o:become: cd $(dirname {})"
#  --history="$HOME/.fzf_history" --history-size=500   # only for Linux
export FZF_DEFAULT_OPTS='--no-height --no-reverse --no-mouse --multi --cycle --tabstop=4 --track --select-1 --no-scrollbar
--bind "ctrl-a:select-all"
--bind "ctrl-d:deselect-all"
--bind "ctrl-n:next-selected,ctrl-p:prev-selected"
--bind "ctrl-d:half-page-down" --bind="ctrl-u:half-page-up"
--bind "alt-up:preview-page-up,alt-down:preview-page-down"
--bind "ctrl-y:execute-silent(echo {} | pbcopy)"
--walker "file,dir,hidden,follow" --walker-skip=".git,.github,.svn,node_modules,target"
--preview "preview {}"
--preview-window hidden
--bind "change:first"
--bind "ctrl-/:toggle-preview"
--bind "f2:toggle-preview"
--bind "focus:transform-preview-label:echo [ {+} ]"
--bind "start:hide-header"
--bind="alt-w:toggle-preview-wrap"
--bind="ctrl-l:clear-query+first"
--bind "ctrl-r:reload(find -type d)"
--bind "ctrl-f:reload(find -type f)"
--bind "ctrl-o:execute(cygstart {+})"
--bind "ctrl-e:execute(vim {+} < /dev/tty > /dev/tty 2>&1)"
--bind "ctrl-g:become(if [[ -d {} ]]; then cd {}; else vim {+} < /dev/tty > /dev/tty 2>&1; fi)"
--bind "ctrl-\\:jump,jump-cancel:transform:[[ $FZF_KEY =~ ctrl-c ]] && echo abort"
--bind="ctrl-s:toggle-sort"
--highlight-line
--color gutter:-1,selected-bg:238,selected-fg:146,current-fg:189
--color hl:underline,hl+:underline
--color hl+:yellow:regular:reverse,query:white:regular,info:gray:regular
--color prompt:yellow:regular,pointer:yellow:bold
--marker ▏ --pointer "▌" --prompt "▌  " '



fzf_my_header='------------------------------------ (keystroke:my binding) ------------------------------------
(ctrl-\\: jump)         (f1: toggle-help)     (f2: toggle-preview)   (ctrl-/: toggle-preview)
(ctrl-a:select-all)     (ctrl-d:deselect-all) (ctrl-t:select-to-top) (ctrl-b:select-to-bottom)
(tab:select-down)       (stab:select-up)      (ctrl-n:next-selected) (ctrl-p:prev-selected)
(ctrl-d:half-page-down) (ctrl-u:half-page-up) (gpup:page-up)         (pgdn:page-down)  (up:up)     (down:down)
(alt-up:page-up)        (alt-down:page-down)  (shift-up:up)          (shift-down:down) (ctrl-j:up) (ctrl-k:down)
(ctrl-l:clear-screen)   (ctrl-e:vim edit)     (ctrl-o:cygstart open)  # vim or cygstart | xdg-open
CTRL-/|F2 toggle preview window; F1 toggle my help; ? toggle fzf help'

export FZF_DEFAULT_OPTS="$FZF_DEFAULT_OPTS --header \"$fzf_my_header\" --bind 'f1:toggle-header'"

echo "------------------------------------ (keystroke:default binding) ------------------------------------
------------------------------------ exit          || ---------------------|-------- layout
abort                | ctrl-c  ctrl-g  ctrl-q  esc || offset-down          | similar to CTRL-E of Vim)
accept               | enter   double-click        || offset-up            | similar to CTRL-Y of Vim)
---------------------|--------- readline           || ---------------------|-------- preview
backward-char        | ctrl-b  left                || preview-down         | shift-down
forward-char         | ctrl-f  right               || preview-up           | shift-up
backward-delete-char | ctrl-h  bspace              || preview-page-down    | alt-down  #
beginning-of-line    | ctrl-a  home                || preview-page-up      | alt-up    #
end-of-line          | ctrl-e  end                 || ---------------------|-------- history
delete-char          |         del                 || next-history         | (ctrl-n on --history)
delete-char/eof      | ctrl-d                      || prev-history         | (ctrl-p on --history)
clear-screen         | ctrl-l                      || ---------------------|-------- marker
unix-line-discard    | ctrl-u                      || deselect-all         | ctrl-d    #
unix-word-rubout     | ctrl-w                      || select-all           | ctrl-a    #
---------------------|--------- layout             || toggle+up            | btab    (shift-tab)
down                 | ctrl-j  ctrl-n  down        || toggle+down          | ctrl-i  (tab)
up                   | ctrl-k  ctrl-p  up          || toggle-header        | F1 ?      #
page-down            | pgdn                        || toggle-preview       | F2 ctrl-/ #
page-up              | pgup                        || jump                 | ctrl-\\   #
------------------------------------ (search:fuzzy-match) ------------------------------------
------------------------------------ extended-search mode (Search syntax)
Token       Match type                   Description    # toggle-sort      | ctrl-s
sbtrkt      fuzzy-match                  匹配sbtrkt     fuzzy
^music      prefix-exact-match           以music开头    ^
.mp3$       suffix-exact-match           以.mp3结尾     $
'wild       exact-match(quoted)          精确包含wild   '
!fire       inverse-exact-match          不包含fire     !       \"!pyc \'travis\": exclude pyc; exactly include travis
!.mp3$      inverse-suffix-exact-match   不以.mp3结尾   !*$
^core go$ | rb$ | py$   以core开头,以go或rb或py结尾的   |
switch\                 switch后紧接空格                \
------------------------------------ Fuzzy completion for bash and zsh ------------------------------------
vim **<TAB>;        cd **<TAB>             || fif    find-in-file - usage: fif <searchTerm>  # frg <arg>; frgi [arg]; frgl <arg>
vim ../**<TAB>                             || ftags  browse; ctags-generated index of symbols in the sources
vim ../fzf**<TAB>;  cd ~/github/fzf**<TAB> || vgd    cd into the directory of the selected file - usage: vgd  [FUZZY PATTERN]
vim ~/**<TAB>                              || git fuzzy        run git add and git reset by selecting or cursoring
kill -9 **<TAB>                            || ugit / git undo  helps undo git commands. Your damage control git buddy
ssh **<TAB>                                || git forgit       A utility tool powered by fzf for using git interactively.
telnet **<TAB>                             || export FZF_DEFAULT_OPTS_FILE=~/.fzfrc
unset **<TAB>                              || ctrl-r     Paste the selected command from history onto the command-line
export **<TAB>                             || ctrl-t     cd into the selected directory
unalias **<TAB>                            || alt-a      Paste the selected files and directories onto the command-line
------------------------------------Key bindings for command-line ------------------------------------
bind -x '\C-x\C-o:fzfo'      # fzf + cygstart                      ==> open
bind -x '\C-x\C-e:fzfv'      # fzf + vim                           ==> vim
bind -x '\C-x\C-v:fzfe'      # fzf + edit                          ==> editor
bind -x '\C-x\C-y:fzfy'      # fzf + ~/.local/share/yank_history   ==> yank
bind -x '\C-x\C-d:fdf'       # fzf + cd                            ==> directory
bind -x '\C-x\C-t:fzftmp'    # fzf + tmp                           ==> tmp
bind -x '\C-x\C-x:fzfcheat'  # fzf + cheat                         ==> cheat
bind -x '\C-x\C-u:eu'        # fzf + ubuntu                        ==> ubuntu
bind -x '\C-x\C-m:fman'      # fzf + manual                        ==> manual
bind -x '\C-x\C-r:ugit'      # fzf + manual                        ==> revert
CTRL-X CTRL-G fzf-marks/fzf-marks.plugin.bash  FZF_MARKS_JUMP='\C-x\C-g'
CTRL-X CTRL-P james-w/fzf-cheatsheets          bind -m emacs-standard -x '\C-x\C-p: fzf-cheatsheets-widget'
CTRL-X CTRL-L cheat-fzf/src/cht-fzf.sh         bind -m emacs-standard -x '\C-x\C-l: chtfzf'
bind -X 2>&1 | grep -e fzf -e 'C-x'            # show fzf
"> /var/tmp/fzf_self_header

export FZF_DEFAULT_OPTS="$FZF_DEFAULT_OPTS --bind '?:preview: preview /var/tmp/fzf_self_header' "                             # 提供fzf默认绑定帮助
export FZF_CTRL_R_OPTS="$FZF_DEFAULT_OPTS $FZF_CTRL_R_OPTS --preview 'echo {}' --preview-window down:3:hidden:wrap --bind '?:toggle-preview'"  # 预览窗口中的完整命令
export FZF_CTRL_R_OPTS="$FZF_DEFAULT_OPTS $FZF_CTRL_R_OPTS --no-sort --exact --bind enter:accept-or-print-query "                              # 排序和精确匹配
export FZF_CTRL_T_OPTS="$FZF_DEFAULT_OPTS $FZF_CTRL_T_OPTS --select-1 --exit-0"    # 如果只有一个项目,--select-1 会自动选择该项目,这样就不用按回车键了.同样,--exit-0 会在列表为空时自动退出


dirdiff(){
    # Shell-escape each path:
    DIR1=$(printf '%q' "$1"); shift
    DIR2=$(printf '%q' "$1"); shift
    vim "$@" -c "DirDiff $DIR1 $DIR2"
}

[ -f ~/.fzf/fzf_complete.sh  ] && source ~/.fzf/fzf_complete.sh    # mklast/mklastv/mklastq/mklaste/mksdk/cdp/cdb/put_pkg by complete
[ -f ~/.fzf/mark_complete.sh  ] && source ~/.fzf/mark_complete.sh  # mkb(goln) linkname; mkg(goto) by complete
[ -f ~/.fzf/cheat.bash  ] && source ~/.fzf/cheat.bash              # cheat by complete
# [ -f ~/.fzf/fzf-simple-completion.sh  ] && source ~/.fzf/fzf-simple-completion.sh              # cheat by complete
# [ -f ~/.fzf/fzf_frg_frgi_frgl.sh  ] && source ~/.fzf/fzf_frg_frgi_frgl.sh

# Fig post block. Keep at the bottom of this file.
# [[ -f "$HOME/.fig/shell/bashrc.post.bash" ]] && builtin source "$HOME/.fig/shell/bashrc.post.bash"

[ -f ~/.vim/bin/zoxide ] && { # https://github.com/ajeetdsouza/zoxide same fzf-marks
eval "$(zoxide init bash)"
alias zq='zoxide query --interactive'
alias za='zoxide add $(pwd)'
alias zr='zoxide remove '

z() {
  local dir=$(
    zoxide query --list --score |
    fzf --height 40% --layout reverse --info inline \
        --nth 2.. --tac --no-sort --query "$*" \
        --bind 'enter:become:echo {2..}'
  ) && cd "$dir"
}
}

alias upnice="sudo renice -n -15 -p $(ps -o pid,cmd | awk '/bash/{print $1}') "
alias dnnice="sudo renice -n 0 -p $(ps -o pid,cmd | awk '/bash/{print $1}') "
alias disable_ipv6="sudo bash -c 'echo 1 > /proc/sys/net/ipv6/conf/all/disable_ipv6'"

# 自动解压：判断文件后缀名并调用相应解压命令
function q-extract() {
    if [ -f $1 ] ; then
        case $1 in
        *.tar.bz2)   tar -xvjf $1    ;;
        *.tar.gz)    tar -xvzf $1    ;;
        *.tar.xz)    tar -xvJf $1    ;;
        *.bz2)       bunzip2 $1     ;;
        *.rar)       rar x $1       ;;
        *.gz)        gunzip $1      ;;
        *.tar)       tar -xvf $1     ;;
        *.tbz2)      tar -xvjf $1    ;;
        *.tgz)       tar -xvzf $1    ;;
        *.zip)       unzip $1       ;;
        *.Z)         uncompress $1  ;;
        *.7z)        7z x $1        ;;
        *)           echo "don't know how to extract '$1'..." ;;
        esac
    else
        echo "'$1' is not a valid file!"
    fi
}

# 自动压缩：判断后缀名并调用相应压缩程序
function q-compress() {
    if [ -n "$1" ] ; then
        FILE=$1
        case $FILE in
        *.tar) shift && tar -cf $FILE $* ;;
        *.tar.bz2) shift && tar -cjf $FILE $* ;;
        *.tar.xz) shift && tar -cJf $FILE $* ;;
        *.tar.gz) shift && tar -czf $FILE $* ;;
        *.tgz) shift && tar -czf $FILE $* ;;
        *.zip) shift && zip $FILE $* ;;
        *.rar) shift && rar $FILE $* ;;
        esac
    else
        echo "usage: q-compress <foo.tar.gz> ./foo ./bar"
    fi
}

# 漂亮的带语法高亮的 color cat ，需要先 pip install pygments
function ccat() {
    local style="monokai"
    if [ $# -eq 0 ]; then
        pygmentize -P style=$style -P tabsize=4 -f terminal256 -g
    else
        for NAME in "$@"; do
            pygmentize -P style=$style -P tabsize=4 -f terminal256 -g "$NAME"
        done
    fi
}

# argc-completions
export ARGC_COMPLETIONS_ROOT="/ftptmp/snippets/argc-completions"
export ARGC_COMPLETIONS_PATH="$ARGC_COMPLETIONS_ROOT/completions/linux:$ARGC_COMPLETIONS_ROOT/completions"
export PATH="$ARGC_COMPLETIONS_ROOT/bin:$PATH"
# To add completions for only the specified command, modify next line e.g. argc_scripts=( cargo git )
argc_scripts=( $(ls -p -1 "$ARGC_COMPLETIONS_ROOT/completions/linux" "$ARGC_COMPLETIONS_ROOT/completions" | sed -n 's/\.sh$//p') )
source <(argc --argc-completions bash "${argc_scripts[@]}")

source /home/wangfuli/.config/broot/launcher/bash/br

export FZF_COMPLETION_TRIGGER='\'
source ~/.fzf/shell/key-bindings.bash
source ~/.fzf/shell/completion.bash
# FZF_ALT_C_COMMAND= eval "$(fzf --bash)"
_fzf_setup_completion dir ranger tree
_fzf_setup_completion path code bat e np npe npp nppe

[ -f ~/.fzf.bash ] && source ~/.fzf.bash
bind -x '"\C-t":fdf0'

function tv_smart_autocomplete() {
  # prefix (lhs of cursor)
  local current_prompt="${READLINE_LINE:0:$READLINE_POINT}"

  local output=$(tv --autocomplete-prompt "$current_prompt" | tr '\n' ' ')

  if [[ -n $output ]]; then
    # suffix (rhs of cursor)
    local rhs="${READLINE_LINE:$READLINE_POINT}"
    # add a space if the prompt does not end with one
    [[ "${current_prompt}" != *" " ]] && current_prompt="${current_prompt} "

    local lhs=$current_prompt$output
    READLINE_LINE=$lhs$rhs
    READLINE_POINT=${#lhs}
  fi
}

bind -x '"\C-P": tv_smart_autocomplete'

alias tla='telnetwfl admin "476t*_f0%g09y" '
alias tlr='telnetwfl root  "476t*_f0%g09y" '
alias tlna='telnetwfl admin "Z2-VQ%G!9urdP" '
alias tlnr='telnetwfl root  "Z2-VQ%G!9urdP" '
alias tlr111='telnetwfl    root "890h*_f0%g09y" 192.168.111.1'


# Codi
# Usage: codi [filetype] [filename]
codi() {
  local syntax="${1:-python}"
  shift
  vim -c \
    "let g:startify_disable_at_vimenter = 1 |\
    set bt=nofile ls=0 noru nonu nornu |\
    hi ColorColumn ctermbg=NONE |\
    hi VertSplit ctermbg=NONE |\
    hi NonText ctermfg=0 |\
    Codi $syntax" "$@"
}

export NAP_CONFIG="~/.nap/config.yaml"
export NAP_HOME="~/.nap"
export NAP_DEFAULT_LANGUAGE="sh"
export NAP_THEME="nord"

export NAP_PRIMARY_COLOR="#AFBEE1"
export NAP_RED="#A46060"
export NAP_GREEN="#527251"
export NAP_FOREGROUND="7"
export NAP_BACKGROUND="0"
export NAP_BLACK="#373B41"
export NAP_GRAY="240"
export NAP_WHITE="#FFFFFF"

napc(){
  local language="sh"
  local ext=$(echo ${1##*.})
  if [ -n "$ext" ] ; then
    language="$ext"
  fi
  nap $language/$1 < $1
}


gitproxy(){
  git config --global http.proxy  "socks5://$1:7890"
  git config --global https.proxy "socks5://$1:7890"

  git config -l | sed -n '/proxy/p'

  export "ALL_PROXY=socks5://$1:7890"
  export "http_proxy=socks5://$1:7890"
  export "https_proxy=socks5://$1:7890"
}

gitproxyip(){
  ipaddr=$(sudo arp-scan -I br0 192.168.122.1/24 2>/dev/null | awk '/58:11:22:d9:92:57/{ print $1 }')
  [ -z "$ipaddr" ] && {
    ipaddr=$(sudo arp-scan -I br0 192.168.123.1/24 2>/dev/null | awk '/58:11:22:d9:92:57/{ print $1 }')
  }
  echo $ipaddr
}

# getdeviceip '58:11:22:d9:92:57' # as gitproxyip
getdeviceip () {
  [ -z "$1" ] && { echo "give mac say ip in local network"; return 0; }
  local mac=$(echo $1 | tr 'A-Z' 'a-z')
  ipaddr=$(sudo arp-scan -I ens33 192.168.122.1/24 2>/dev/null | grep "$mac" | awk '{ print $1 }');
  [ -z "$ipaddr" ] && {
    ipaddr=$(sudo arp-scan -I ens33 192.168.123.1/24 2>/dev/null | grep "$mac" | awk '{ print $1 }')
  };
  echo $ipaddr
}
# getdevicesrv 22; getdevicesrv 23 --> nmap -A  192.168.122.0/24
getdevicesrv () {
  [ -z "$1" ] && { echo "give service port say ip in local network"; return 0; }
  if [ -n "$2" ]; then
    nmap -p $1 --open -sV $2/24 | grep -v 'SERVICE' | grep -v 'Host is up' | sed -n '/^$/!p'
  else
      nmap -p $1 --open -sV 192.168.122.0/24 | grep -v 'SERVICE' | grep -v 'Host is up' | sed -n '/^$/!p'
      nmap -p $1 --open -sV 192.168.123.0/24 | grep -v 'SERVICE' | grep -v 'Host is up' | sed -n '/^$/!p'
  fi
}
